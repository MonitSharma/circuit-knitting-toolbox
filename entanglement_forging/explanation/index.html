<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.19: https://docutils.sourceforge.io/" />

    <title>Explanatory material for the entanglement forging module &#8212; Circuit Knitting Toolbox 0.1.0 documentation</title>
    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/alabaster.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/jupyter-sphinx.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/thebelab.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/style.css" />
    <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/sphinx_highlight.js"></script>
    <script src="../../_static/thebelab-helper.js"></script>
    <script src="../../_static/clipboard.min.js"></script>
    <script src="../../_static/copybutton.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@jupyter-widgets/html-manager@^1.0.1/dist/embed-amd.js"></script>
    <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script>window.MathJax = {"tex": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true}, "options": {"ignoreHtmlClass": "tex2jax_ignore|mathjax_ignore|document", "processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
    <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="Entanglement Forging How-To Guides" href="../how-tos/index.html" />
    <link rel="prev" title="Tutorial 2: Entanglement Forging with Quantum Serverless" href="../tutorials/tutorial_2_forging_with_quantum_serverless.html" />
   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="explanatory-material-for-the-entanglement-forging-module">
<h1>Explanatory material for the entanglement forging module<a class="headerlink" href="#explanatory-material-for-the-entanglement-forging-module" title="Permalink to this heading">¶</a></h1>
<section id="overview-of-entanglement-forging">
<h2>Overview of entanglement forging<a class="headerlink" href="#overview-of-entanglement-forging" title="Permalink to this heading">¶</a></h2>
<p>Entanglement forging [1] was introduced as a way to reduce the number of
qubits necessary to perform quantum simulation of chemical or physical
systems. In general, to simulate <span class="math notranslate nohighlight">\(n\)</span> orbitals in a chemistry problem,
one typically needs <span class="math notranslate nohighlight">\(2n\)</span> qubits. Entanglement Forging makes it
possible to represent expectation values of a <span class="math notranslate nohighlight">\(2n\)</span>-qubit wavefunction
as sums of multiple expectation values of <span class="math notranslate nohighlight">\(n\)</span>-qubit states, embedded in
a classical computation, thus doubling the size of the system that can
be <em>exactly</em> simulated with a fixed number of qubits. Furthermore,
Entanglement Forging permits the circuits necessary for the <span class="math notranslate nohighlight">\(n\)</span>-qubit
simulations to be shallower, relaxing requirements on gate error and
connectivity, at the cost of increased quantum and classical run times.</p>
<p>Previous techniques for reducing qubit count in quantum simulation
applications could either reduce qubits slightly at the expense of
deeper circuits (e.g. 2-qubit reduction, tapering), or yield a 50% qubit
reduction at the expense of lower accuracy (e.g. restricted
simulations). Using Entanglement Forging, one can achieve a 50%
reduction in the number of qubits without compromising accuracy.</p>
<p>The underlying idea which enables Entanglement Forging is that a quantum
system on <span class="math notranslate nohighlight">\(2n\)</span> qubits can be partitioned into 2 subsystems, and that a
Schmidt decomposition of the <span class="math notranslate nohighlight">\(2n\)</span>-qubit wavefunction with respect to
those subsystems is possible. Because of this decomposition, we obtain
an accurate classical representation of the entanglement between the two
subsystems.</p>
<p>The schematic below outlines how the expectation value <span class="math notranslate nohighlight">\(M\)</span> of a
<span class="math notranslate nohighlight">\(2n\)</span>-qubit wavefunction <span class="math notranslate nohighlight">\(\lvert \psi \rangle_{2n}\)</span>  with respect to a <span class="math notranslate nohighlight">\(2n\)</span>-qubit
Hamiltonian <span class="math notranslate nohighlight">\(H_{2n}\)</span> can be decomposed into a sum of expectation values
of products of <span class="math notranslate nohighlight">\(n\)</span>-qubit wavefunctions with respect to <span class="math notranslate nohighlight">\(n\)</span>-qubit
operators. These <span class="math notranslate nohighlight">\(n\)</span>-qubit expectation values correspond to
sub-experiments.</p>
<figure class="align-default" id="id3">
<img alt="Entanglement Forging Infographic" src="../../_images/forging_info_graphic.png" />
<figcaption>
<p><span class="caption-number">Fig. 1 </span><span class="caption-text">Entanglement Forging Infographic</span><a class="headerlink" href="#id3" title="Permalink to this image">¶</a></p>
</figcaption>
</figure>
</section>
<section id="entanglement-forging-procedure">
<h2>Entanglement Forging Procedure<a class="headerlink" href="#entanglement-forging-procedure" title="Permalink to this heading">¶</a></h2>
<p>Entanglement Forging leverages near-term, heuristic algorithms, such as
VQE, to provide an estimate of the <span class="math notranslate nohighlight">\(2n\)</span>-qubit expectation value. It
does so by assuming a parameterized ansatz for the wavefunction of each
sub-system. (Note that the parameters of this ansatz describe the
unitaries <span class="math notranslate nohighlight">\(U\)</span> and <span class="math notranslate nohighlight">\(V\)</span> in the Schmidt decomposition.) After the
expectation value <span class="math notranslate nohighlight">\(M\)</span> has been decomposed into sub-experiments, the
procedure is as follows:</p>
<ol class="arabic simple">
<li><p>Execute each sub-experiment on the QPU a number of times necessary
to obtain sufficient statistics.</p></li>
<li><p>Combine the expectation values for the sub-experiments with the
weights <span class="math notranslate nohighlight">\(w_{a,b}\)</span> and the Schmidt parameters <span class="math notranslate nohighlight">\(λ_n\)</span> to
obtain an estimate for <span class="math notranslate nohighlight">\(M\)</span>.</p></li>
<li><p>Send the estimate of <span class="math notranslate nohighlight">\(M\)</span>, along with <span class="math notranslate nohighlight">\(λ_n\)</span> and the
variational parameters <span class="math notranslate nohighlight">\(\{θ\}\)</span> describing <span class="math notranslate nohighlight">\(U\)</span> and
<span class="math notranslate nohighlight">\(V\)</span>, to a classical optimizer.</p></li>
<li><p>Use the classical optimizer to further minimize <span class="math notranslate nohighlight">\(M\)</span> and
provide a new set for the variational parameters <span class="math notranslate nohighlight">\(\{θ\}\)</span> and
Schmidt coefficients <span class="math notranslate nohighlight">\(λ_n\)</span>.</p></li>
<li><p>Update the sub-experiments based on the updated <span class="math notranslate nohighlight">\(\{θ\}\)</span> and
<span class="math notranslate nohighlight">\(λ_n\)</span>.</p></li>
<li><p>Repeat Steps 1-5 until the estimate for <span class="math notranslate nohighlight">\(M\)</span> converges.</p></li>
</ol>
<p>Note that if <span class="math notranslate nohighlight">\(M\)</span> is the expectation value of the system’s Hamiltonian,
then it is possible to separate the optimization over the variational
parameters <span class="math notranslate nohighlight">\(\{θ\}\)</span> and the Schmidt coefficients <span class="math notranslate nohighlight">\(λ_n\)</span>. In particular, the
Schmidt coefficients can be optimized after step 2, and separately from
the variational parameters.</p>
<p>Further, an easy way to reduce the number of sub-experiments necessary
is by truncating the Schmidt decomposition of <span class="math notranslate nohighlight">\(\lvert\psi\rangle\)</span> to include only some
number of the bitstring states <span class="math notranslate nohighlight">\(\lvert b_n \rangle\)</span>. However, doing so will
generally lead to less accuracy in the estimation of the expectation
value.</p>
</section>
<section id="scaling">
<h2>Scaling<a class="headerlink" href="#scaling" title="Permalink to this heading">¶</a></h2>
<p>The execution time scales differently with various properties of the
simulations, and is indicated in the table below.</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Quantity</p></th>
<th class="head"><p>Scaling</p></th>
<th class="head"><p>Notes</p></th>
<th class="head"><p>Ways to
Reduce</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>Orbitals</p></td>
<td><p>Fifth power</p></td>
<td></td>
<td><p><a class="reference internal" href="#freezing-orbitals"><span class="std std-ref">Orbital
freezing</span></a></p></td>
</tr>
<tr class="row-odd"><td><p>Bitstring
states
<span class="math notranslate nohighlight">\(\lvert
b_n \rangle\)</span></p></td>
<td><p>Quadratic</p></td>
<td><p>Increasing
the number of
bitstring
states can
increase the
accuracy of
the
simulation,
but at the
expense of
execution
time.</p></td>
<td><p><a class="reference internal" href="#picking-the-bitstrings"><span class="std std-ref">Schmidt
decomposition
truncation</span></a></p></td>
</tr>
<tr class="row-even"><td><p>Ansatz
parameters
<span class="math notranslate nohighlight">\(\{θ\}\)</span></p></td>
<td><p>Linear</p></td>
<td><p>An increased
number of
ansatz
parameters
can increase
the accuracy
of the
simulation,
but at the
expense of
execution
time.</p></td>
<td><p><a class="reference internal" href="#ansatz-design"><span class="std std-ref">Redesign
the ansatz</span></a></p></td>
</tr>
</tbody>
</table>
<section id="freezing-orbitals">
<span id="id1"></span><h3>Freezing orbitals<a class="headerlink" href="#freezing-orbitals" title="Permalink to this heading">¶</a></h3>
<p>Since the execution time scales with the 5th power in the number of
orbitals, it’s a good idea to simplify the problem (if possible) by
eliminating some of the orbitals. Some knowledge of chemistry is useful
when picking orbitals to freeze. One good rule of thumb is to freeze the
core orbital (for the case of water, this is the core oxygen 1s
orbital). Furthermore, in the case of water, it turns out that orbital 3
(corresponding to the out-of-plane oxygen 2p orbitals) has different
symmetry to the other orbitals, so excitations to orbital 3 are
suppressed. For water, we thus freeze orbitals 0 and 3.</p>
<section id="example-water-molecule">
<h4>Example: Water molecule<a class="headerlink" href="#example-water-molecule" title="Permalink to this heading">¶</a></h4>
<p>The total number of orbitals (core + valence) = 7 orbitals</p>
<p>Frozen orbital approximation = 2 orbitals</p>
<p>Active space orbitals = total number of orbitals – frozen orbitals = 5
orbitals (bitstring size is set to 5)</p>
<p>Leading excitation analysis = 3 unique bitstrings</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">circuit_knitting_toolbox.utils</span> <span class="kn">import</span> <span class="n">reduce_bitstrings</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">orbitals_to_reduce</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bitstrings</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">reduced_bitstrings</span> <span class="o">=</span> <span class="n">reduce_bitstrings</span><span class="p">(</span><span class="n">bitstrings</span><span class="p">,</span> <span class="n">orbitals_to_reduce</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Bitstrings after orbital reduction: </span><span class="si">{</span><span class="n">reduced_bitstrings</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
<span class="go">Bitstrings after orbital reduction: [[1, 1, 1, 0, 0], [0, 1, 1, 0, 1], [0, 1, 1, 1, 0]]</span>
</pre></div>
</div>
<p>A complete example is provided in the <a class="reference internal" href="../how-tos/freeze-orbitals.html"><span class="doc">guide on freezing orbitals</span></a>.</p>
</section>
</section>
<section id="picking-the-bitstrings">
<span id="id2"></span><h3>Picking the bitstrings<a class="headerlink" href="#picking-the-bitstrings" title="Permalink to this heading">¶</a></h3>
<section id="general-considerations">
<h4>General Considerations<a class="headerlink" href="#general-considerations" title="Permalink to this heading">¶</a></h4>
<p>Picking appropriate bitstrings requires prior knowledge of the molecular
electronic structure.</p>
<p>In general, the exact electronic wavefunction is a superposition of all
possible distributions of the <span class="math notranslate nohighlight">\(N\)</span> electrons over the <span class="math notranslate nohighlight">\(L\)</span>
orbitals and is exponential in size. However, only a relatively small
number of excitations contribute significantly to the correlation
energy. By identifying such leading electronic excitations, a linear
combination of electronic configurations/Slater determinants that
capture the most important portion of the Hilbert space and make the
biggest contribution to the electronic wavefunction description can be
selected. This allows for reduction in computational resources.</p>
<p>The leading electronic excitations can be represented in standard
bitstrings (e.g. <code class="docutils literal notranslate"><span class="pre">[1,1,1,1,0,0,0]</span></code>). When an orbital is occupied by a
spin up (α electron) or spin down (β electron), its bit will be set to
1. Therefore:</p>
<ul class="simple">
<li><p>the number of bits in each bitstring should be equal the
number of spatial orbitals</p></li>
<li><p>the number of 1s in each bitstring should
equal the number of α or β particles.</p></li>
</ul>
<p>Further reduction in computational resources can be achieved by
<a class="reference internal" href="#freezing-orbitals"><span class="std std-ref">freezing some orbitals</span></a>
that do not participate in electronic excitations (i.e. core orbitals or
those that lie out of symmetry) by removing the bits that correspond to
them.</p>
</section>
</section>
<section id="designing-the-ansatz-used-in-entanglement-forging">
<span id="ansatz-design"></span><h3>Designing the ansatz used in Entanglement Forging<a class="headerlink" href="#designing-the-ansatz-used-in-entanglement-forging" title="Permalink to this heading">¶</a></h3>
<p>Because entanglement forging leverages a near-term, heuristic algorithm
(namely, VQE), a judicious choice for the VQE ansatz can improve
performance. Note that one way to design the ansatz is by endowing the
unitaries <span class="math notranslate nohighlight">\(U\)</span> and <span class="math notranslate nohighlight">\(V\)</span> in the Schmidt decomposition with parameters. An
open question is how to choose the best unitaries for a given problem.</p>
<p>For a chemistry simulation problem, the number of qubits in the circuit
must equal the number of orbitals (minus the number of frozen orbitals,
if applicable).</p>
</section>
</section>
<section id="current-limitations">
<h2>⚠️ Current limitations<a class="headerlink" href="#current-limitations" title="Permalink to this heading">¶</a></h2>
<section id="ansatz-bitstrings">
<h3>Ansatz &amp; bitstrings<a class="headerlink" href="#ansatz-bitstrings" title="Permalink to this heading">¶</a></h3>
<ul class="simple">
<li><p>It is currently an open problem how to pick the best circuit
(ansatze) for VQE (and thus Entanglement Forging) for a given system.</p></li>
<li><p>It is also currently an open problem how to pick the best bitstring
for Entanglement Forging.</p></li>
<li><p>In the current implementation of the module, the same ansatz circuit
is used for both spin-up and spin-down systems, U and V.</p></li>
<li><p>In the current implementation of the module, the ansatz must be real.</p>
<ul>
<li><p>For molecular calculations, one can usually force the ansatz to be
real. On the other hand, in crystalline solids (away from the
gamma point and without inversion symmetry), the Hamiltonian is
defined by the complex numbers.</p></li>
<li><p>There are plans in the future to implement complex ansatze.</p></li>
</ul>
</li>
</ul>
</section>
<section id="results">
<h3>Results<a class="headerlink" href="#results" title="Permalink to this heading">¶</a></h3>
<ul class="simple">
<li><p>In the current implementation, only the energy of the final state is
available. It would be useful to have a feature to output the 1- and
2-body density matrices of the final state after the optimization.</p>
<ul>
<li><p>The 1-body matrices are used for:</p>
<ul>
<li><p>electrostatic properties</p></li>
<li><p>electronic densities</p></li>
<li><p>molecular electrostatic potential</p></li>
</ul>
</li>
<li><p>2-body matrices are used for:</p>
<ul>
<li><p>orbital optimization</p></li>
<li><p>analysis of correlation functions</p></li>
</ul>
</li>
<li><p>The combination of both is used in entanglement analysis.</p></li>
</ul>
</li>
</ul>
</section>
<section id="running-on-quantum-hardware">
<h3>Running on quantum hardware<a class="headerlink" href="#running-on-quantum-hardware" title="Permalink to this heading">¶</a></h3>
<p>Results on hardware will not be as good as on the QASM simulator.
Getting good results will require using a quantum backend with good
properties (qubit fidelity, gate fidelity etc.), as well as a lot of
fine-tuning of parameters.</p>
</section>
<section id="pauli-grouping">
<h3>Pauli grouping<a class="headerlink" href="#pauli-grouping" title="Permalink to this heading">¶</a></h3>
<p>There is currently no Pauli grouping for the expectation value experiments
calculated at each iteration, so expectation values are calculated on the
full Pauli basis. This can result in long training times for larger systems.</p>
</section>
</section>
<section id="references">
<h2>References<a class="headerlink" href="#references" title="Permalink to this heading">¶</a></h2>
<p>This module is based on the theory and experiment described in the
following paper:</p>
<p>[1] Andrew Eddins, Mario Motta, Tanvi P. Gujarati, Sergey Bravyi,
Antonio Mezzacapo, Charles Hadfield, Sarah Sheldon, <em>Doubling the size
of quantum simulators by entanglement forging</em>,
<a class="reference external" href="https://arxiv.org/abs/2104.10220">https://arxiv.org/abs/2104.10220</a></p>
</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../index.html">Circuit Knitting Toolbox</a></h1>








<h3>Navigation</h3>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../install.html">Installation Instructions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../circuit_cutting/tutorials/index.html">Circuit Cutting Tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../circuit_cutting/explanation/index.html">Circuit Cutting Explanatory Material</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../circuit_cutting/how-tos/index.html">Circuit Cutting How-To Guides</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../circuit_cutting/cutqc/index.html">CutQC (legacy circuit cutting implementation)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tutorials/index.html">Entanglement Forging Tutorials</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Entanglement Forging Explanatory Material</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#overview-of-entanglement-forging">Overview of entanglement forging</a></li>
<li class="toctree-l2"><a class="reference internal" href="#entanglement-forging-procedure">Entanglement Forging Procedure</a></li>
<li class="toctree-l2"><a class="reference internal" href="#scaling">Scaling</a></li>
<li class="toctree-l2"><a class="reference internal" href="#current-limitations">⚠️ Current limitations</a></li>
<li class="toctree-l2"><a class="reference internal" href="#references">References</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../how-tos/index.html">Entanglement Forging How-To Guides</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../apidocs/index.html">API References</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../release-notes.html">Release Notes</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../index.html">Documentation overview</a><ul>
      <li>Previous: <a href="../tutorials/tutorial_2_forging_with_quantum_serverless.html" title="previous chapter">Tutorial 2: Entanglement Forging with Quantum Serverless</a></li>
      <li>Next: <a href="../how-tos/index.html" title="next chapter">Entanglement Forging How-To Guides</a></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2023.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 7.0.0</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.13</a>
      
      |
      <a href="../../_sources/entanglement_forging/explanation/index.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>