<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>circuit_knitting_toolbox.circuit_cutting.cutqc.wire_cutting &#8212; Circuit Knitting Toolbox 0.1.0 documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/alabaster.css" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/jupyter-sphinx.css" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/thebelab.css" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/style.css" />
    <script data-url_root="../../../../" id="documentation_options" src="../../../../_static/documentation_options.js"></script>
    <script src="../../../../_static/doctools.js"></script>
    <script src="../../../../_static/sphinx_highlight.js"></script>
    <script src="../../../../_static/thebelab-helper.js"></script>
    <script src="../../../../_static/clipboard.min.js"></script>
    <script src="../../../../_static/copybutton.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@jupyter-widgets/html-manager@^1.0.1/dist/embed-amd.js"></script>
    <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" />
   
  <link rel="stylesheet" href="../../../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <h1>Source code for circuit_knitting_toolbox.circuit_cutting.cutqc.wire_cutting</h1><div class="highlight"><pre>
<span></span><span class="c1"># This code is a Qiskit project.</span>

<span class="c1"># (C) Copyright IBM 2022.</span>

<span class="c1"># This code is licensed under the Apache License, Version 2.0. You may</span>
<span class="c1"># obtain a copy of this license in the LICENSE.txt file in the root directory</span>
<span class="c1"># of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.</span>
<span class="c1"># Any modifications or derivative works of this code must retain this</span>
<span class="c1"># copyright notice, and modified files need to carry a notice indicating</span>
<span class="c1"># that they have been altered from the originals.</span>

<span class="sd">&quot;&quot;&quot;Functions for conducting the wire cutting on quantum circuits.&quot;&quot;&quot;</span>

<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">annotations</span>

<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Sequence</span><span class="p">,</span> <span class="n">Any</span><span class="p">,</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">cast</span><span class="p">,</span> <span class="n">no_type_check</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">qiskit</span> <span class="kn">import</span> <span class="n">QuantumCircuit</span><span class="p">,</span> <span class="n">QuantumRegister</span>
<span class="kn">from</span> <span class="nn">qiskit.circuit</span> <span class="kn">import</span> <span class="n">Qubit</span>
<span class="kn">from</span> <span class="nn">qiskit.dagcircuit</span> <span class="kn">import</span> <span class="n">DAGCircuit</span><span class="p">,</span> <span class="n">DAGOpNode</span>
<span class="kn">from</span> <span class="nn">qiskit.converters</span> <span class="kn">import</span> <span class="n">circuit_to_dag</span><span class="p">,</span> <span class="n">dag_to_circuit</span>
<span class="kn">from</span> <span class="nn">qiskit_ibm_runtime</span> <span class="kn">import</span> <span class="n">Options</span><span class="p">,</span> <span class="n">QiskitRuntimeService</span>

<span class="kn">from</span> <span class="nn">.wire_cutting_evaluation</span> <span class="kn">import</span> <span class="n">run_subcircuit_instances</span>
<span class="kn">from</span> <span class="nn">.wire_cutting_post_processing</span> <span class="kn">import</span> <span class="n">generate_summation_terms</span><span class="p">,</span> <span class="n">build</span>
<span class="kn">from</span> <span class="nn">.wire_cutting_verification</span> <span class="kn">import</span> <span class="n">generate_reconstructed_output</span>


<div class="viewcode-block" id="cut_circuit_wires"><a class="viewcode-back" href="../../../../stubs/circuit_knitting_toolbox.circuit_cutting.cutqc.cut_circuit_wires.html#circuit_knitting_toolbox.circuit_cutting.cutqc.cut_circuit_wires">[docs]</a><span class="k">def</span> <span class="nf">cut_circuit_wires</span><span class="p">(</span>
    <span class="n">circuit</span><span class="p">:</span> <span class="n">QuantumCircuit</span><span class="p">,</span>
    <span class="n">method</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
    <span class="n">subcircuit_vertices</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">]]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">max_subcircuit_width</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">max_subcircuit_cuts</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">max_subcircuit_size</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">max_cuts</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">num_subcircuits</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">verbose</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Decompose the circuit into a collection of subcircuits.</span>

<span class="sd">    Args:</span>
<span class="sd">        method: Whether to have the cuts be &#39;automatically&#39; found, in a</span>
<span class="sd">            provably optimal way, or whether to &#39;manually&#39; specify the cuts</span>
<span class="sd">        subcircuit_vertices: The vertices to be used in the subcircuits. Note</span>
<span class="sd">            that these are not the indices of the qubits, but the nodes in the circuit DAG</span>
<span class="sd">        max_subcircuit_width: Max number of qubits in each subcircuit</span>
<span class="sd">        max_cuts: Max total number of cuts allowed</span>
<span class="sd">        num_subcircuits: List of number of subcircuits to try</span>
<span class="sd">        max_subcircuit_cuts: Max number of cuts for a subcircuit</span>
<span class="sd">        max_subcircuit_size: Max number of gates in a subcircuit</span>
<span class="sd">        verbose: Flag for printing output of cutting</span>

<span class="sd">    Returns:</span>
<span class="sd">        A dictionary containing information on the cuts, including the subcircuits</span>
<span class="sd">        themselves (key: &#39;subcircuits&#39;)</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: The input method does not match the other provided arguments</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">cuts</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;automatic&quot;</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">max_subcircuit_width</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;The max_subcircuit_width argument must be set if using automatic cut finding.&quot;</span>
            <span class="p">)</span>
        <span class="n">cuts</span> <span class="o">=</span> <span class="n">find_wire_cuts</span><span class="p">(</span>
            <span class="n">circuit</span><span class="o">=</span><span class="n">circuit</span><span class="p">,</span>
            <span class="n">max_subcircuit_width</span><span class="o">=</span><span class="n">max_subcircuit_width</span><span class="p">,</span>
            <span class="n">max_cuts</span><span class="o">=</span><span class="n">max_cuts</span><span class="p">,</span>
            <span class="n">num_subcircuits</span><span class="o">=</span><span class="n">num_subcircuits</span><span class="p">,</span>
            <span class="n">max_subcircuit_cuts</span><span class="o">=</span><span class="n">max_subcircuit_cuts</span><span class="p">,</span>
            <span class="n">max_subcircuit_size</span><span class="o">=</span><span class="n">max_subcircuit_size</span><span class="p">,</span>
            <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span>
        <span class="p">)</span>
    <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;manual&quot;</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">subcircuit_vertices</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;The subcircuit_vertices argument must be set if manually specifying cuts.&quot;</span>
            <span class="p">)</span>
        <span class="n">cuts</span> <span class="o">=</span> <span class="n">cut_circuit_wire</span><span class="p">(</span>
            <span class="n">circuit</span><span class="o">=</span><span class="n">circuit</span><span class="p">,</span> <span class="n">subcircuit_vertices</span><span class="o">=</span><span class="n">subcircuit_vertices</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span>
        <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s1">&#39;The method argument for the decompose method should be either &quot;automatic&quot; or &quot;manual&quot;.&#39;</span>
        <span class="p">)</span>

    <span class="k">return</span> <span class="n">cuts</span></div>


<div class="viewcode-block" id="evaluate_subcircuits"><a class="viewcode-back" href="../../../../stubs/circuit_knitting_toolbox.circuit_cutting.cutqc.evaluate_subcircuits.html#circuit_knitting_toolbox.circuit_cutting.cutqc.evaluate_subcircuits">[docs]</a><span class="k">def</span> <span class="nf">evaluate_subcircuits</span><span class="p">(</span>
    <span class="n">cuts</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">],</span>
    <span class="n">service</span><span class="p">:</span> <span class="n">QiskitRuntimeService</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">backend_names</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">options</span><span class="p">:</span> <span class="n">Options</span> <span class="o">|</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Options</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Evaluate the subcircuits.</span>

<span class="sd">    Args:</span>
<span class="sd">        cuts: The results of cutting</span>
<span class="sd">        service: A service for connecting to Qiskit Runtime Service</span>
<span class="sd">        options: Options to use on each backend</span>
<span class="sd">        backend_names: The name(s) of the backend(s) to be used</span>

<span class="sd">    Returns:</span>
<span class="sd">        The dictionary containing the results from running each of the subcircuits</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Put backend_names and options in lists to ensure it is unambiguous how to sync them</span>
    <span class="n">backends_list</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">options_list</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Options</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">if</span> <span class="n">backend_names</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">backend_names</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">options</span><span class="p">,</span> <span class="n">Options</span><span class="p">):</span>
            <span class="n">options_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">options</span><span class="p">]</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">options</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">options</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">options_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">options</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">backend_names</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">backends_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">backend_names</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">backends_list</span> <span class="o">=</span> <span class="n">backend_names</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">options</span><span class="p">,</span> <span class="n">Options</span><span class="p">):</span>
            <span class="n">options_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">options</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">backends_list</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">options</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">options_list</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">backends_list</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">options_list</span> <span class="o">=</span> <span class="n">options</span>

    <span class="k">if</span> <span class="n">backend_names</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">backends_list</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">options_list</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;The list of backend names is length (</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">backends_list</span><span class="p">)</span><span class="si">}</span><span class="s2">), &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;but the list of options is length (</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">options_list</span><span class="p">)</span><span class="si">}</span><span class="s2">). &quot;</span>
                <span class="s2">&quot;It is ambiguous how these options should be applied.&quot;</span>
            <span class="p">)</span>

    <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">subcircuit_instances</span> <span class="o">=</span> <span class="n">_generate_metadata</span><span class="p">(</span><span class="n">cuts</span><span class="p">)</span>

    <span class="n">subcircuit_instance_probabilities</span> <span class="o">=</span> <span class="n">_run_subcircuits</span><span class="p">(</span>
        <span class="n">cuts</span><span class="p">,</span>
        <span class="n">subcircuit_instances</span><span class="p">,</span>
        <span class="n">service</span><span class="o">=</span><span class="n">service</span><span class="p">,</span>
        <span class="n">backend_names</span><span class="o">=</span><span class="n">backends_list</span><span class="p">,</span>
        <span class="n">options</span><span class="o">=</span><span class="n">options_list</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="k">return</span> <span class="n">subcircuit_instance_probabilities</span></div>


<div class="viewcode-block" id="reconstruct_full_distribution"><a class="viewcode-back" href="../../../../stubs/circuit_knitting_toolbox.circuit_cutting.cutqc.reconstruct_full_distribution.html#circuit_knitting_toolbox.circuit_cutting.cutqc.reconstruct_full_distribution">[docs]</a><span class="k">def</span> <span class="nf">reconstruct_full_distribution</span><span class="p">(</span>
    <span class="n">circuit</span><span class="p">:</span> <span class="n">QuantumCircuit</span><span class="p">,</span>
    <span class="n">subcircuit_instance_probabilities</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]],</span>
    <span class="n">cuts</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">],</span>
    <span class="n">num_threads</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Reconstruct the full probabilities from the subcircuit evaluations.</span>

<span class="sd">    Args:</span>
<span class="sd">        circuit: The original full circuit</span>
<span class="sd">        subcircuit_instance_probabilities: The probability vectors from each</span>
<span class="sd">            of the subcircuit instances, as output by the _run_subcircuits function</span>
<span class="sd">        num_threads: The number of threads to use to parallelize the recomposing</span>

<span class="sd">    Returns:</span>
<span class="sd">        The reconstructed probability vector</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">summation_terms</span><span class="p">,</span> <span class="n">subcircuit_entries</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">_generate_metadata</span><span class="p">(</span><span class="n">cuts</span><span class="p">)</span>

    <span class="n">subcircuit_entry_probabilities</span> <span class="o">=</span> <span class="n">_attribute_shots</span><span class="p">(</span>
        <span class="n">subcircuit_entries</span><span class="p">,</span> <span class="n">subcircuit_instance_probabilities</span>
    <span class="p">)</span>

    <span class="n">unordered_probability</span><span class="p">,</span> <span class="n">smart_order</span><span class="p">,</span> <span class="n">overhead</span> <span class="o">=</span> <span class="n">build</span><span class="p">(</span>
        <span class="n">summation_terms</span><span class="o">=</span><span class="n">summation_terms</span><span class="p">,</span>
        <span class="n">subcircuit_entry_probs</span><span class="o">=</span><span class="n">subcircuit_entry_probabilities</span><span class="p">,</span>
        <span class="n">num_cuts</span><span class="o">=</span><span class="n">cuts</span><span class="p">[</span><span class="s2">&quot;num_cuts&quot;</span><span class="p">],</span>
        <span class="n">num_threads</span><span class="o">=</span><span class="n">num_threads</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="n">reconstructed_probability</span> <span class="o">=</span> <span class="n">generate_reconstructed_output</span><span class="p">(</span>
        <span class="n">circuit</span><span class="p">,</span>
        <span class="n">cuts</span><span class="p">[</span><span class="s2">&quot;subcircuits&quot;</span><span class="p">],</span>
        <span class="n">unordered_probability</span><span class="p">,</span>
        <span class="n">smart_order</span><span class="p">,</span>
        <span class="n">cuts</span><span class="p">[</span><span class="s2">&quot;complete_path_map&quot;</span><span class="p">],</span>
    <span class="p">)</span>

    <span class="k">return</span> <span class="n">reconstructed_probability</span></div>


<span class="k">def</span> <span class="nf">_generate_metadata</span><span class="p">(</span>
    <span class="n">cuts</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span>
    <span class="nb">list</span><span class="p">[</span><span class="nb">dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]],</span>
    <span class="nb">dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">],</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]]]],</span>
    <span class="nb">dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="o">...</span><span class="p">],</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">Any</span><span class="p">,</span> <span class="o">...</span><span class="p">]],</span> <span class="nb">int</span><span class="p">]],</span>
<span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generate metadata used to execute subcircuits and reconstruct probabilities of original circuit.</span>

<span class="sd">    Args:</span>
<span class="sd">        cuts: Results from the cutting step</span>

<span class="sd">    Returns:</span>
<span class="sd">        Information about the 4^(num cuts) summation terms used to reconstruct original</span>
<span class="sd">        probabilities, a dictionary with information on each of the subcircuits, and a dictionary</span>
<span class="sd">        containing indexes for each of the subcircuits</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="p">(</span>
        <span class="n">summation_terms</span><span class="p">,</span>
        <span class="n">subcircuit_entries</span><span class="p">,</span>
        <span class="n">subcircuit_instances</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">=</span> <span class="n">generate_summation_terms</span><span class="p">(</span>
        <span class="n">subcircuits</span><span class="o">=</span><span class="n">cuts</span><span class="p">[</span><span class="s2">&quot;subcircuits&quot;</span><span class="p">],</span>
        <span class="n">complete_path_map</span><span class="o">=</span><span class="n">cuts</span><span class="p">[</span><span class="s2">&quot;complete_path_map&quot;</span><span class="p">],</span>
        <span class="n">num_cuts</span><span class="o">=</span><span class="n">cuts</span><span class="p">[</span><span class="s2">&quot;num_cuts&quot;</span><span class="p">],</span>
    <span class="p">)</span>
    <span class="k">return</span> <span class="n">summation_terms</span><span class="p">,</span> <span class="n">subcircuit_entries</span><span class="p">,</span> <span class="n">subcircuit_instances</span>


<span class="k">def</span> <span class="nf">_run_subcircuits</span><span class="p">(</span>
    <span class="n">cuts</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">],</span>
    <span class="n">subcircuit_instances</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="o">...</span><span class="p">],</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">Any</span><span class="p">,</span> <span class="o">...</span><span class="p">]],</span> <span class="nb">int</span><span class="p">]],</span>
    <span class="n">service</span><span class="p">:</span> <span class="n">QiskitRuntimeService</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">backend_names</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">options</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Options</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Execute all the subcircuit instances.</span>

<span class="sd">    task[&#39;subcircuit_instance_probs&#39;][subcircuit_idx][subcircuit_instance_idx] = measured prob</span>

<span class="sd">    Args:</span>
<span class="sd">        cuts: Results from the cutting step</span>
<span class="sd">        subcircuit_instances: The dictionary containing the index information for each</span>
<span class="sd">            of the subcircuit instances</span>
<span class="sd">        service: The arguments for the runtime service</span>
<span class="sd">        backend_names: The backend(s) used to run the subcircuits</span>
<span class="sd">        options: Options for the runtime execution of subcircuits</span>

<span class="sd">    Returns:</span>
<span class="sd">        The resulting probabilities from each of the subcircuit instances</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">subcircuit_instance_probs</span> <span class="o">=</span> <span class="n">run_subcircuit_instances</span><span class="p">(</span>
        <span class="n">subcircuits</span><span class="o">=</span><span class="n">cuts</span><span class="p">[</span><span class="s2">&quot;subcircuits&quot;</span><span class="p">],</span>
        <span class="n">subcircuit_instances</span><span class="o">=</span><span class="n">subcircuit_instances</span><span class="p">,</span>
        <span class="n">service</span><span class="o">=</span><span class="n">service</span><span class="p">,</span>
        <span class="n">backend_names</span><span class="o">=</span><span class="n">backend_names</span><span class="p">,</span>
        <span class="n">options</span><span class="o">=</span><span class="n">options</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="k">return</span> <span class="n">subcircuit_instance_probs</span>


<span class="k">def</span> <span class="nf">_attribute_shots</span><span class="p">(</span>
    <span class="n">subcircuit_entries</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span>
        <span class="nb">int</span><span class="p">,</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">],</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]]]</span>
    <span class="p">],</span>
    <span class="n">subcircuit_instance_probs</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]],</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Attribute the shots into respective subcircuit entries.</span>

<span class="sd">    task[&#39;subcircuit_entry_probs&#39;][subcircuit_idx][subcircuit_entry_idx] = prob</span>

<span class="sd">    Args:</span>
<span class="sd">        subcircuit_entries: Dictionary containing information about each of the</span>
<span class="sd">            subcircuit instances</span>
<span class="sd">        subcircuit_instance_probs: The probability vectors from each of the subcircuit</span>
<span class="sd">            instances, as output by the _run_subcircuits function</span>

<span class="sd">    Returns:</span>
<span class="sd">        A dictionary containing the probability results to each of the appropriate subcircuits</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: A kronecker term is not size two</span>
<span class="sd">        ValueError: There are no subcircuit probs provided</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">subcircuit_entry_probs</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]]</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">subcircuit_idx</span> <span class="ow">in</span> <span class="n">subcircuit_entries</span><span class="p">:</span>
        <span class="n">subcircuit_entry_probs</span><span class="p">[</span><span class="n">subcircuit_idx</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">subcircuit_entries</span><span class="p">[</span><span class="n">subcircuit_idx</span><span class="p">]:</span>
            <span class="n">subcircuit_entry_idx</span><span class="p">,</span> <span class="n">kronecker_term</span> <span class="o">=</span> <span class="n">subcircuit_entries</span><span class="p">[</span><span class="n">subcircuit_idx</span><span class="p">][</span>
                <span class="n">label</span>
            <span class="p">]</span>
            <span class="n">subcircuit_entry_prob</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">for</span> <span class="n">coefficient</span><span class="p">,</span> <span class="n">subcircuit_instance_idx</span> <span class="ow">in</span> <span class="n">kronecker_term</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">subcircuit_entry_prob</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">subcircuit_entry_prob</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="n">coefficient</span>
                        <span class="o">*</span> <span class="n">subcircuit_instance_probs</span><span class="p">[</span><span class="n">subcircuit_idx</span><span class="p">][</span>
                            <span class="n">subcircuit_instance_idx</span>
                        <span class="p">]</span>
                    <span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">subcircuit_entry_prob</span> <span class="o">+=</span> <span class="p">(</span>
                        <span class="n">coefficient</span>
                        <span class="o">*</span> <span class="n">subcircuit_instance_probs</span><span class="p">[</span><span class="n">subcircuit_idx</span><span class="p">][</span>
                            <span class="n">subcircuit_instance_idx</span>
                        <span class="p">]</span>
                    <span class="p">)</span>

            <span class="k">if</span> <span class="n">subcircuit_entry_prob</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Something unexpected happened during shot attribution.&quot;</span>
                <span class="p">)</span>
            <span class="n">subcircuit_entry_probs</span><span class="p">[</span><span class="n">subcircuit_idx</span><span class="p">][</span>
                <span class="n">subcircuit_entry_idx</span>
            <span class="p">]</span> <span class="o">=</span> <span class="n">subcircuit_entry_prob</span>

    <span class="k">return</span> <span class="n">subcircuit_entry_probs</span>


<span class="nd">@no_type_check</span>
<span class="k">def</span> <span class="nf">find_wire_cuts</span><span class="p">(</span>
    <span class="n">circuit</span><span class="p">:</span> <span class="n">QuantumCircuit</span><span class="p">,</span>
    <span class="n">max_subcircuit_width</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">max_cuts</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">num_subcircuits</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">max_subcircuit_cuts</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">max_subcircuit_size</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">verbose</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Find optimal cuts for the wires.</span>

<span class="sd">    Will print if the model cannot find a solution at all, and will print whether</span>
<span class="sd">    the found solution is optimal or not.</span>

<span class="sd">    Args:</span>
<span class="sd">        circuit: Original quantum circuit to be cut into subcircuits</span>
<span class="sd">        max_subcircuit_width: Max number of qubits in each subcircuit</span>
<span class="sd">        max_cuts: Max total number of cuts allowed</span>
<span class="sd">        num_subcircuits: List of number of subcircuits to try</span>
<span class="sd">        max_subcircuit_cuts: Max number of cuts for a subcircuit</span>
<span class="sd">        max_subcircuit_size: The maximum number of two qubit gates in each</span>
<span class="sd">            subcircuit</span>
<span class="sd">        verbose: Whether to print information about the cut finding or not</span>

<span class="sd">    Returns:</span>
<span class="sd">        The solution found for the cuts</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">stripped_circ</span> <span class="o">=</span> <span class="n">_circuit_stripping</span><span class="p">(</span><span class="n">circuit</span><span class="o">=</span><span class="n">circuit</span><span class="p">)</span>
    <span class="n">n_vertices</span><span class="p">,</span> <span class="n">edges</span><span class="p">,</span> <span class="n">vertex_ids</span><span class="p">,</span> <span class="n">id_vertices</span> <span class="o">=</span> <span class="n">_read_circuit</span><span class="p">(</span><span class="n">circuit</span><span class="o">=</span><span class="n">stripped_circ</span><span class="p">)</span>
    <span class="n">num_qubits</span> <span class="o">=</span> <span class="n">circuit</span><span class="o">.</span><span class="n">num_qubits</span>
    <span class="n">cut_solution</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">min_cost</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="s2">&quot;inf&quot;</span><span class="p">)</span>

    <span class="n">best_mip_model</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">for</span> <span class="n">num_subcircuit</span> <span class="ow">in</span> <span class="n">num_subcircuits</span><span class="p">:</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="n">num_subcircuit</span> <span class="o">*</span> <span class="n">max_subcircuit_width</span> <span class="o">-</span> <span class="p">(</span><span class="n">num_subcircuit</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">num_qubits</span>
            <span class="ow">or</span> <span class="n">num_subcircuit</span> <span class="o">&gt;</span> <span class="n">num_qubits</span>
            <span class="ow">or</span> <span class="n">max_cuts</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="n">num_subcircuit</span>
        <span class="p">):</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%d</span><span class="s2"> subcircuits : IMPOSSIBLE&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">num_subcircuit</span><span class="p">))</span>
            <span class="k">continue</span>
        <span class="n">kwargs</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
            <span class="n">n_vertices</span><span class="o">=</span><span class="n">n_vertices</span><span class="p">,</span>
            <span class="n">edges</span><span class="o">=</span><span class="n">edges</span><span class="p">,</span>
            <span class="n">vertex_ids</span><span class="o">=</span><span class="n">vertex_ids</span><span class="p">,</span>
            <span class="n">id_vertices</span><span class="o">=</span><span class="n">id_vertices</span><span class="p">,</span>
            <span class="n">num_subcircuit</span><span class="o">=</span><span class="n">num_subcircuit</span><span class="p">,</span>
            <span class="n">max_subcircuit_width</span><span class="o">=</span><span class="n">max_subcircuit_width</span><span class="p">,</span>
            <span class="n">max_subcircuit_cuts</span><span class="o">=</span><span class="n">max_subcircuit_cuts</span><span class="p">,</span>
            <span class="n">max_subcircuit_size</span><span class="o">=</span><span class="n">max_subcircuit_size</span><span class="p">,</span>
            <span class="n">num_qubits</span><span class="o">=</span><span class="n">num_qubits</span><span class="p">,</span>
            <span class="n">max_cuts</span><span class="o">=</span><span class="n">max_cuts</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="kn">from</span> <span class="nn">.mip_model</span> <span class="kn">import</span> <span class="n">MIPModel</span>

        <span class="n">mip_model</span> <span class="o">=</span> <span class="n">MIPModel</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">feasible</span> <span class="o">=</span> <span class="n">mip_model</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">min_postprocessing_cost</span><span class="o">=</span><span class="n">min_cost</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">feasible</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%d</span><span class="s2"> subcircuits : NO SOLUTIONS&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">num_subcircuit</span><span class="p">))</span>
            <span class="k">continue</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">positions</span> <span class="o">=</span> <span class="n">_cuts_parser</span><span class="p">(</span><span class="n">mip_model</span><span class="o">.</span><span class="n">cut_edges</span><span class="p">,</span> <span class="n">circuit</span><span class="p">)</span>
            <span class="n">subcircuits</span><span class="p">,</span> <span class="n">complete_path_map</span> <span class="o">=</span> <span class="n">_subcircuits_parser</span><span class="p">(</span>
                <span class="n">subcircuit_gates</span><span class="o">=</span><span class="n">mip_model</span><span class="o">.</span><span class="n">subcircuits</span><span class="p">,</span> <span class="n">circuit</span><span class="o">=</span><span class="n">circuit</span>
            <span class="p">)</span>
            <span class="n">O_rho_pairs</span> <span class="o">=</span> <span class="n">_get_pairs</span><span class="p">(</span><span class="n">complete_path_map</span><span class="o">=</span><span class="n">complete_path_map</span><span class="p">)</span>
            <span class="n">counter</span> <span class="o">=</span> <span class="n">_get_counter</span><span class="p">(</span><span class="n">subcircuits</span><span class="o">=</span><span class="n">subcircuits</span><span class="p">,</span> <span class="n">O_rho_pairs</span><span class="o">=</span><span class="n">O_rho_pairs</span><span class="p">)</span>

            <span class="n">classical_cost</span> <span class="o">=</span> <span class="n">_cost_estimate</span><span class="p">(</span><span class="n">counter</span><span class="o">=</span><span class="n">counter</span><span class="p">)</span>
            <span class="n">cost</span> <span class="o">=</span> <span class="n">classical_cost</span>

            <span class="k">if</span> <span class="n">cost</span> <span class="o">&lt;</span> <span class="n">min_cost</span><span class="p">:</span>
                <span class="n">min_cost</span> <span class="o">=</span> <span class="n">cost</span>
                <span class="n">best_mip_model</span> <span class="o">=</span> <span class="n">mip_model</span>
                <span class="n">cut_solution</span> <span class="o">=</span> <span class="p">{</span>
                    <span class="s2">&quot;max_subcircuit_width&quot;</span><span class="p">:</span> <span class="n">max_subcircuit_width</span><span class="p">,</span>
                    <span class="s2">&quot;subcircuits&quot;</span><span class="p">:</span> <span class="n">subcircuits</span><span class="p">,</span>
                    <span class="s2">&quot;complete_path_map&quot;</span><span class="p">:</span> <span class="n">complete_path_map</span><span class="p">,</span>
                    <span class="s2">&quot;num_cuts&quot;</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">positions</span><span class="p">),</span>
                    <span class="s2">&quot;counter&quot;</span><span class="p">:</span> <span class="n">counter</span><span class="p">,</span>
                    <span class="s2">&quot;classical_cost&quot;</span><span class="p">:</span> <span class="n">classical_cost</span><span class="p">,</span>
                <span class="p">}</span>
    <span class="k">if</span> <span class="n">verbose</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">cut_solution</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;-&quot;</span> <span class="o">*</span> <span class="mi">20</span><span class="p">)</span>
        <span class="n">classical_cost</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">cut_solution</span><span class="p">[</span><span class="s2">&quot;classical_cost&quot;</span><span class="p">])</span>
        <span class="c1"># We can remove typing.Dict from this cast statement when py38 is deprecated.</span>
        <span class="c1"># https://bugs.python.org/issue45117</span>
        <span class="n">counter</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="n">Dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]],</span> <span class="n">cut_solution</span><span class="p">[</span><span class="s2">&quot;counter&quot;</span><span class="p">])</span>
        <span class="n">subcircuits</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="n">cut_solution</span><span class="p">[</span><span class="s2">&quot;subcircuits&quot;</span><span class="p">]</span>
        <span class="n">num_cuts</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="n">cut_solution</span><span class="p">[</span><span class="s2">&quot;num_cuts&quot;</span><span class="p">]</span>
        <span class="n">_print_cutter_result</span><span class="p">(</span>
            <span class="n">num_subcircuit</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">subcircuits</span><span class="p">),</span>
            <span class="n">num_cuts</span><span class="o">=</span><span class="n">num_cuts</span><span class="p">,</span>
            <span class="n">subcircuits</span><span class="o">=</span><span class="n">subcircuits</span><span class="p">,</span>
            <span class="n">counter</span><span class="o">=</span><span class="n">counter</span><span class="p">,</span>
            <span class="n">classical_cost</span><span class="o">=</span><span class="n">classical_cost</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="n">best_mip_model</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Something went wrong during cut finding. The best MIP model object was never instantiated.&quot;</span>
            <span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Model objective value = </span><span class="si">%.2e</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">best_mip_model</span><span class="o">.</span><span class="n">objective</span><span class="p">),</span> <span class="n">flush</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>  <span class="c1"># type: ignore</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;MIP runtime:&quot;</span><span class="p">,</span> <span class="n">best_mip_model</span><span class="o">.</span><span class="n">runtime</span><span class="p">,</span> <span class="n">flush</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">best_mip_model</span><span class="o">.</span><span class="n">optimal</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;OPTIMAL, MIP gap =&quot;</span><span class="p">,</span> <span class="n">best_mip_model</span><span class="o">.</span><span class="n">mip_gap</span><span class="p">,</span> <span class="n">flush</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;NOT OPTIMAL, MIP gap =&quot;</span><span class="p">,</span> <span class="n">best_mip_model</span><span class="o">.</span><span class="n">mip_gap</span><span class="p">,</span> <span class="n">flush</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;-&quot;</span> <span class="o">*</span> <span class="mi">20</span><span class="p">,</span> <span class="n">flush</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">cut_solution</span>


<span class="k">def</span> <span class="nf">cut_circuit_wire</span><span class="p">(</span>
    <span class="n">circuit</span><span class="p">:</span> <span class="n">QuantumCircuit</span><span class="p">,</span> <span class="n">subcircuit_vertices</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">]],</span> <span class="n">verbose</span><span class="p">:</span> <span class="nb">bool</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Perform the provided cuts.</span>

<span class="sd">    Used when cut locations are chosen manually.</span>

<span class="sd">    Args:</span>
<span class="sd">        circuit: Original quantum circuit to be cut into subcircuits</span>
<span class="sd">        subcircuit_vertices: The list of vertices to apply the cuts to</span>
<span class="sd">        verbose: Whether to print the details of cutting or not</span>

<span class="sd">    Returns:</span>
<span class="sd">        The solution calculated from the provided cuts</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">stripped_circ</span> <span class="o">=</span> <span class="n">_circuit_stripping</span><span class="p">(</span><span class="n">circuit</span><span class="o">=</span><span class="n">circuit</span><span class="p">)</span>
    <span class="n">n_vertices</span><span class="p">,</span> <span class="n">edges</span><span class="p">,</span> <span class="n">vertex_ids</span><span class="p">,</span> <span class="n">id_vertices</span> <span class="o">=</span> <span class="n">_read_circuit</span><span class="p">(</span><span class="n">circuit</span><span class="o">=</span><span class="n">stripped_circ</span><span class="p">)</span>

    <span class="n">subcircuit_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">vertices</span> <span class="ow">in</span> <span class="n">subcircuit_vertices</span><span class="p">:</span>
        <span class="n">subcircuit</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">vertex</span> <span class="ow">in</span> <span class="n">vertices</span><span class="p">:</span>
            <span class="n">subcircuit</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">id_vertices</span><span class="p">[</span><span class="n">vertex</span><span class="p">])</span>
        <span class="n">subcircuit_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">subcircuit</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">sum</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">subcircuit</span><span class="p">)</span> <span class="k">for</span> <span class="n">subcircuit</span> <span class="ow">in</span> <span class="n">subcircuit_list</span><span class="p">])</span> <span class="o">!=</span> <span class="n">n_vertices</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Not all gates are assigned into subcircuits&quot;</span><span class="p">)</span>

    <span class="n">subcircuit_object</span> <span class="o">=</span> <span class="n">_subcircuits_parser</span><span class="p">(</span>
        <span class="n">subcircuit_gates</span><span class="o">=</span><span class="n">subcircuit_list</span><span class="p">,</span> <span class="n">circuit</span><span class="o">=</span><span class="n">circuit</span>
    <span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">subcircuit_object</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;subcircuit_object should contain exactly two elements.&quot;</span><span class="p">)</span>
    <span class="n">subcircuits</span> <span class="o">=</span> <span class="n">subcircuit_object</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">complete_path_map</span> <span class="o">=</span> <span class="n">subcircuit_object</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

    <span class="n">O_rho_pairs</span> <span class="o">=</span> <span class="n">_get_pairs</span><span class="p">(</span><span class="n">complete_path_map</span><span class="o">=</span><span class="n">complete_path_map</span><span class="p">)</span>
    <span class="n">counter</span> <span class="o">=</span> <span class="n">_get_counter</span><span class="p">(</span><span class="n">subcircuits</span><span class="o">=</span><span class="n">subcircuits</span><span class="p">,</span> <span class="n">O_rho_pairs</span><span class="o">=</span><span class="n">O_rho_pairs</span><span class="p">)</span>
    <span class="n">classical_cost</span> <span class="o">=</span> <span class="n">_cost_estimate</span><span class="p">(</span><span class="n">counter</span><span class="o">=</span><span class="n">counter</span><span class="p">)</span>
    <span class="n">max_subcircuit_width</span> <span class="o">=</span> <span class="nb">max</span><span class="p">([</span><span class="n">subcirc</span><span class="o">.</span><span class="n">width</span><span class="p">()</span> <span class="k">for</span> <span class="n">subcirc</span> <span class="ow">in</span> <span class="n">subcircuits</span><span class="p">])</span>  <span class="c1"># type: ignore</span>

    <span class="n">cut_solution</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;max_subcircuit_width&quot;</span><span class="p">:</span> <span class="n">max_subcircuit_width</span><span class="p">,</span>
        <span class="s2">&quot;subcircuits&quot;</span><span class="p">:</span> <span class="n">subcircuits</span><span class="p">,</span>
        <span class="s2">&quot;complete_path_map&quot;</span><span class="p">:</span> <span class="n">complete_path_map</span><span class="p">,</span>
        <span class="s2">&quot;num_cuts&quot;</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">O_rho_pairs</span><span class="p">),</span>
        <span class="s2">&quot;counter&quot;</span><span class="p">:</span> <span class="n">counter</span><span class="p">,</span>
        <span class="s2">&quot;classical_cost&quot;</span><span class="p">:</span> <span class="n">classical_cost</span><span class="p">,</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;-&quot;</span> <span class="o">*</span> <span class="mi">20</span><span class="p">)</span>
        <span class="n">_print_cutter_result</span><span class="p">(</span>
            <span class="n">num_subcircuit</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">cut_solution</span><span class="p">[</span><span class="s2">&quot;subcircuits&quot;</span><span class="p">]),</span>
            <span class="n">num_cuts</span><span class="o">=</span><span class="n">cut_solution</span><span class="p">[</span><span class="s2">&quot;num_cuts&quot;</span><span class="p">],</span>
            <span class="n">subcircuits</span><span class="o">=</span><span class="n">cut_solution</span><span class="p">[</span><span class="s2">&quot;subcircuits&quot;</span><span class="p">],</span>
            <span class="n">counter</span><span class="o">=</span><span class="n">cut_solution</span><span class="p">[</span><span class="s2">&quot;counter&quot;</span><span class="p">],</span>
            <span class="n">classical_cost</span><span class="o">=</span><span class="n">cut_solution</span><span class="p">[</span><span class="s2">&quot;classical_cost&quot;</span><span class="p">],</span>
        <span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;-&quot;</span> <span class="o">*</span> <span class="mi">20</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">cut_solution</span>


<span class="k">def</span> <span class="nf">_print_cutter_result</span><span class="p">(</span>
    <span class="n">num_subcircuit</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">num_cuts</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">subcircuits</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">QuantumCircuit</span><span class="p">],</span>
    <span class="n">counter</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]],</span>
    <span class="n">classical_cost</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Pretty print the results.</span>

<span class="sd">    Args:</span>
<span class="sd">        num_subciruit: The number of subcircuits</span>
<span class="sd">        num_cuts: The number of cuts</span>
<span class="sd">        subcircuits: The list of subcircuits</span>
<span class="sd">        counter: The dictionary containing all meta information regarding</span>
<span class="sd">            each of the subcircuits</span>
<span class="sd">        classical_cost: The estimated processing cost</span>

<span class="sd">    Returns:</span>
<span class="sd">        None</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">for</span> <span class="n">subcircuit_idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_subcircuit</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;subcircuit </span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">subcircuit_idx</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span>
            <span class="s2">&quot;</span><span class="se">\u03C1</span><span class="s2"> qubits = </span><span class="si">%d</span><span class="s2">, O qubits = </span><span class="si">%d</span><span class="s2">, width = </span><span class="si">%d</span><span class="s2">, effective = </span><span class="si">%d</span><span class="s2">, depth = </span><span class="si">%d</span><span class="s2">, size = </span><span class="si">%d</span><span class="s2">&quot;</span>
            <span class="o">%</span> <span class="p">(</span>
                <span class="n">counter</span><span class="p">[</span><span class="n">subcircuit_idx</span><span class="p">][</span><span class="s2">&quot;rho&quot;</span><span class="p">],</span>
                <span class="n">counter</span><span class="p">[</span><span class="n">subcircuit_idx</span><span class="p">][</span><span class="s2">&quot;O&quot;</span><span class="p">],</span>
                <span class="n">counter</span><span class="p">[</span><span class="n">subcircuit_idx</span><span class="p">][</span><span class="s2">&quot;d&quot;</span><span class="p">],</span>
                <span class="n">counter</span><span class="p">[</span><span class="n">subcircuit_idx</span><span class="p">][</span><span class="s2">&quot;effective&quot;</span><span class="p">],</span>
                <span class="n">counter</span><span class="p">[</span><span class="n">subcircuit_idx</span><span class="p">][</span><span class="s2">&quot;depth&quot;</span><span class="p">],</span>
                <span class="n">counter</span><span class="p">[</span><span class="n">subcircuit_idx</span><span class="p">][</span><span class="s2">&quot;size&quot;</span><span class="p">],</span>
            <span class="p">)</span>
        <span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">subcircuits</span><span class="p">[</span><span class="n">subcircuit_idx</span><span class="p">])</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Estimated cost = </span><span class="si">%.3e</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">classical_cost</span><span class="p">,</span> <span class="n">flush</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_cuts_parser</span><span class="p">(</span>
    <span class="n">cuts</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">]],</span> <span class="n">circ</span><span class="p">:</span> <span class="n">QuantumCircuit</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="n">Qubit</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert cuts to wires.</span>

<span class="sd">    Args:</span>
<span class="sd">        cuts: The cuts found by the model (or provided by the user)</span>
<span class="sd">        circ: The quantum circuit the cuts are from</span>

<span class="sd">    Returns:</span>
<span class="sd">        The list containing the wires that were cut and the gates</span>
<span class="sd">        that are affected by these cuts</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">dag</span> <span class="o">=</span> <span class="n">circuit_to_dag</span><span class="p">(</span><span class="n">circ</span><span class="p">)</span>
    <span class="n">positions</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">position</span> <span class="ow">in</span> <span class="n">cuts</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">position</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;position variable should be a length 2 sequence: </span><span class="si">{position}</span><span class="s2">&quot;</span>
            <span class="p">)</span>
        <span class="n">source</span> <span class="o">=</span> <span class="n">position</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">dest</span> <span class="o">=</span> <span class="n">position</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">source_qargs</span> <span class="o">=</span> <span class="p">[</span>
            <span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;]&quot;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="s2">&quot;]&quot;</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;]&quot;</span><span class="p">)[</span><span class="mi">1</span><span class="p">]))</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">source</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot; &quot;</span><span class="p">)</span>
        <span class="p">]</span>
        <span class="n">dest_qargs</span> <span class="o">=</span> <span class="p">[</span>
            <span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;]&quot;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="s2">&quot;]&quot;</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;]&quot;</span><span class="p">)[</span><span class="mi">1</span><span class="p">]))</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">dest</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot; &quot;</span><span class="p">)</span>
        <span class="p">]</span>
        <span class="n">qubit_cut</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">source_qarg</span> <span class="ow">in</span> <span class="n">source_qargs</span><span class="p">:</span>
            <span class="n">source_qubit</span><span class="p">,</span> <span class="n">source_multi_Q_gate_idx</span> <span class="o">=</span> <span class="n">source_qarg</span>
            <span class="k">for</span> <span class="n">dest_qarg</span> <span class="ow">in</span> <span class="n">dest_qargs</span><span class="p">:</span>
                <span class="n">dest_qubit</span><span class="p">,</span> <span class="n">dest_multi_Q_gate_idx</span> <span class="o">=</span> <span class="n">dest_qarg</span>
                <span class="k">if</span> <span class="p">(</span>
                    <span class="n">source_qubit</span> <span class="o">==</span> <span class="n">dest_qubit</span>
                    <span class="ow">and</span> <span class="n">dest_multi_Q_gate_idx</span> <span class="o">==</span> <span class="n">source_multi_Q_gate_idx</span> <span class="o">+</span> <span class="mi">1</span>
                <span class="p">):</span>
                    <span class="n">qubit_cut</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">source_qubit</span><span class="p">)</span>
        <span class="c1"># if len(qubit_cut)&gt;1:</span>
        <span class="c1">#     raise Exception(&#39;one cut is cutting on multiple qubits&#39;)</span>
        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">source</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot; &quot;</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;]&quot;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="s2">&quot;]&quot;</span> <span class="o">==</span> <span class="n">qubit_cut</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                <span class="n">source_idx</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;]&quot;</span><span class="p">)[</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">dest</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot; &quot;</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;]&quot;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="s2">&quot;]&quot;</span> <span class="o">==</span> <span class="n">qubit_cut</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                <span class="n">dest_idx</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;]&quot;</span><span class="p">)[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">multi_Q_gate_idx</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">source_idx</span><span class="p">,</span> <span class="n">dest_idx</span><span class="p">)</span>

        <span class="n">wire</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">for</span> <span class="n">qubit</span> <span class="ow">in</span> <span class="n">circ</span><span class="o">.</span><span class="n">qubits</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">circ</span><span class="o">.</span><span class="n">find_bit</span><span class="p">(</span><span class="n">qubit</span><span class="p">)</span><span class="o">.</span><span class="n">registers</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="n">qubit_cut</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;[&quot;</span><span class="p">)[</span>
                <span class="mi">0</span>
            <span class="p">]</span> <span class="ow">and</span> <span class="n">circ</span><span class="o">.</span><span class="n">find_bit</span><span class="p">(</span><span class="n">qubit</span><span class="p">)</span><span class="o">.</span><span class="n">index</span> <span class="o">==</span> <span class="nb">int</span><span class="p">(</span>
                <span class="n">qubit_cut</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;[&quot;</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;]&quot;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="p">):</span>
                <span class="n">wire</span> <span class="o">=</span> <span class="n">qubit</span>
        <span class="n">tmp</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">all_Q_gate_idx</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">for</span> <span class="n">gate_idx</span><span class="p">,</span> <span class="n">gate</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span>
            <span class="nb">list</span><span class="p">(</span><span class="n">dag</span><span class="o">.</span><span class="n">nodes_on_wire</span><span class="p">(</span><span class="n">wire</span><span class="o">=</span><span class="n">wire</span><span class="p">,</span> <span class="n">only_ops</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
        <span class="p">):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">gate</span><span class="o">.</span><span class="n">qargs</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">tmp</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="n">tmp</span> <span class="o">==</span> <span class="n">multi_Q_gate_idx</span><span class="p">:</span>
                    <span class="n">all_Q_gate_idx</span> <span class="o">=</span> <span class="n">gate_idx</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">wire</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">all_Q_gate_idx</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Something unexpected happened while parsing cuts.&quot;</span><span class="p">)</span>
        <span class="n">positions</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">wire</span><span class="p">,</span> <span class="n">all_Q_gate_idx</span><span class="p">))</span>
    <span class="n">positions</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">positions</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">cut</span><span class="p">:</span> <span class="n">cut</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">positions</span>


<span class="k">def</span> <span class="nf">_subcircuits_parser</span><span class="p">(</span>
    <span class="n">subcircuit_gates</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]],</span> <span class="n">circuit</span><span class="p">:</span> <span class="n">QuantumCircuit</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="n">QuantumCircuit</span><span class="p">],</span> <span class="nb">dict</span><span class="p">[</span><span class="n">Qubit</span><span class="p">,</span> <span class="nb">list</span><span class="p">[</span><span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span> <span class="o">|</span> <span class="n">Qubit</span><span class="p">]]]]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert the subcircuit gates into quantum circuits and path out the DAGs to enable conversion.</span>

<span class="sd">    Args:</span>
<span class="sd">        subcircuit_gates: The gates in the subcircuits</span>
<span class="sd">        circuit: The original circuit</span>

<span class="sd">    Returns:</span>
<span class="sd">        A tuple containing he subcircuits and the paths in the quantum circuit DAGs</span>
<span class="sd">    &quot;&quot;&quot;</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Assign the single qubit gates to the closest two-qubit gates</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">calculate_distance_between_gate</span><span class="p">(</span><span class="n">gate_A</span><span class="p">,</span> <span class="n">gate_B</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">gate_A</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot; &quot;</span><span class="p">))</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">gate_B</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot; &quot;</span><span class="p">)):</span>
            <span class="n">tmp_gate</span> <span class="o">=</span> <span class="n">gate_A</span>
            <span class="n">gate_A</span> <span class="o">=</span> <span class="n">gate_B</span>
            <span class="n">gate_B</span> <span class="o">=</span> <span class="n">tmp_gate</span>
        <span class="n">distance</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="s2">&quot;inf&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">qarg_A</span> <span class="ow">in</span> <span class="n">gate_A</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot; &quot;</span><span class="p">):</span>
            <span class="n">qubit_A</span> <span class="o">=</span> <span class="n">qarg_A</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;]&quot;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="s2">&quot;]&quot;</span>
            <span class="n">qgate_A</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">qarg_A</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;]&quot;</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">for</span> <span class="n">qarg_B</span> <span class="ow">in</span> <span class="n">gate_B</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot; &quot;</span><span class="p">):</span>
                <span class="n">qubit_B</span> <span class="o">=</span> <span class="n">qarg_B</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;]&quot;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="s2">&quot;]&quot;</span>
                <span class="n">qgate_B</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">qarg_B</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;]&quot;</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
                <span class="c1"># print(&#39;%s gate %d --&gt; %s gate %d&#39;%(qubit_A,qgate_A,qubit_B,qgate_B))</span>
                <span class="k">if</span> <span class="n">qubit_A</span> <span class="o">==</span> <span class="n">qubit_B</span><span class="p">:</span>
                    <span class="n">distance</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">distance</span><span class="p">,</span> <span class="nb">abs</span><span class="p">(</span><span class="n">qgate_B</span> <span class="o">-</span> <span class="n">qgate_A</span><span class="p">))</span>
        <span class="c1"># print(&#39;Distance from %s to %s = %f&#39;%(gate_A,gate_B,distance))</span>
        <span class="k">return</span> <span class="n">distance</span>

    <span class="n">dag</span> <span class="o">=</span> <span class="n">circuit_to_dag</span><span class="p">(</span><span class="n">circuit</span><span class="p">)</span>
    <span class="n">qubit_allGate_depths</span> <span class="o">=</span> <span class="p">{</span><span class="n">x</span><span class="p">:</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">circuit</span><span class="o">.</span><span class="n">qubits</span><span class="p">}</span>
    <span class="n">qubit_2qGate_depths</span> <span class="o">=</span> <span class="p">{</span><span class="n">x</span><span class="p">:</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">circuit</span><span class="o">.</span><span class="n">qubits</span><span class="p">}</span>
    <span class="n">gate_depth_encodings</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="c1"># print(&#39;Before translation :&#39;,subcircuit_gates,flush=True)</span>
    <span class="k">for</span> <span class="n">op_node</span> <span class="ow">in</span> <span class="n">dag</span><span class="o">.</span><span class="n">topological_op_nodes</span><span class="p">():</span>
        <span class="n">gate_depth_encoding</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
        <span class="k">for</span> <span class="n">qarg</span> <span class="ow">in</span> <span class="n">op_node</span><span class="o">.</span><span class="n">qargs</span><span class="p">:</span>
            <span class="n">gate_depth_encoding</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="si">%s</span><span class="s2">[</span><span class="si">%d</span><span class="s2">]</span><span class="si">%d</span><span class="s2"> &quot;</span> <span class="o">%</span> <span class="p">(</span>
                <span class="n">circuit</span><span class="o">.</span><span class="n">find_bit</span><span class="p">(</span><span class="n">qarg</span><span class="p">)</span><span class="o">.</span><span class="n">registers</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
                <span class="n">circuit</span><span class="o">.</span><span class="n">find_bit</span><span class="p">(</span><span class="n">qarg</span><span class="p">)</span><span class="o">.</span><span class="n">index</span><span class="p">,</span>
                <span class="n">qubit_allGate_depths</span><span class="p">[</span><span class="n">qarg</span><span class="p">],</span>
            <span class="p">)</span>
        <span class="n">gate_depth_encoding</span> <span class="o">=</span> <span class="n">gate_depth_encoding</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">gate_depth_encodings</span><span class="p">[</span><span class="n">op_node</span><span class="p">]</span> <span class="o">=</span> <span class="n">gate_depth_encoding</span>
        <span class="k">for</span> <span class="n">qarg</span> <span class="ow">in</span> <span class="n">op_node</span><span class="o">.</span><span class="n">qargs</span><span class="p">:</span>
            <span class="n">qubit_allGate_depths</span><span class="p">[</span><span class="n">qarg</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">op_node</span><span class="o">.</span><span class="n">qargs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">MIP_gate_depth_encoding</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
            <span class="k">for</span> <span class="n">qarg</span> <span class="ow">in</span> <span class="n">op_node</span><span class="o">.</span><span class="n">qargs</span><span class="p">:</span>
                <span class="n">MIP_gate_depth_encoding</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="si">%s</span><span class="s2">[</span><span class="si">%d</span><span class="s2">]</span><span class="si">%d</span><span class="s2"> &quot;</span> <span class="o">%</span> <span class="p">(</span>
                    <span class="n">circuit</span><span class="o">.</span><span class="n">find_bit</span><span class="p">(</span><span class="n">qarg</span><span class="p">)</span><span class="o">.</span><span class="n">registers</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
                    <span class="n">circuit</span><span class="o">.</span><span class="n">find_bit</span><span class="p">(</span><span class="n">qarg</span><span class="p">)</span><span class="o">.</span><span class="n">index</span><span class="p">,</span>
                    <span class="n">qubit_2qGate_depths</span><span class="p">[</span><span class="n">qarg</span><span class="p">],</span>
                <span class="p">)</span>
                <span class="n">qubit_2qGate_depths</span><span class="p">[</span><span class="n">qarg</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">MIP_gate_depth_encoding</span> <span class="o">=</span> <span class="n">MIP_gate_depth_encoding</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="c1"># print(&#39;gate_depth_encoding = %s, MIP_gate_depth_encoding = %s&#39;%(gate_depth_encoding,MIP_gate_depth_encoding))</span>
            <span class="k">for</span> <span class="n">subcircuit_idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">subcircuit_gates</span><span class="p">)):</span>
                <span class="k">for</span> <span class="n">gate_idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">subcircuit_gates</span><span class="p">[</span><span class="n">subcircuit_idx</span><span class="p">])):</span>
                    <span class="k">if</span> <span class="p">(</span>
                        <span class="n">subcircuit_gates</span><span class="p">[</span><span class="n">subcircuit_idx</span><span class="p">][</span><span class="n">gate_idx</span><span class="p">]</span>
                        <span class="o">==</span> <span class="n">MIP_gate_depth_encoding</span>
                    <span class="p">):</span>
                        <span class="n">subcircuit_gates</span><span class="p">[</span><span class="n">subcircuit_idx</span><span class="p">][</span><span class="n">gate_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">gate_depth_encoding</span>
                        <span class="k">break</span>
    <span class="c1"># print(&#39;After translation :&#39;,subcircuit_gates,flush=True)</span>
    <span class="n">subcircuit_op_nodes</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">list</span><span class="p">[</span><span class="n">DAGOpNode</span><span class="p">]]</span> <span class="o">=</span> <span class="p">{</span>
        <span class="n">x</span><span class="p">:</span> <span class="p">[]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">subcircuit_gates</span><span class="p">))</span>
    <span class="p">}</span>
    <span class="n">subcircuit_sizes</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">subcircuit_gates</span><span class="p">))]</span>
    <span class="n">complete_path_map</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="n">Qubit</span><span class="p">,</span> <span class="nb">list</span><span class="p">[</span><span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span> <span class="o">|</span> <span class="n">Qubit</span><span class="p">]]]</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">circuit_qubit</span> <span class="ow">in</span> <span class="n">dag</span><span class="o">.</span><span class="n">qubits</span><span class="p">:</span>
        <span class="n">complete_path_map</span><span class="p">[</span><span class="n">circuit_qubit</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">qubit_ops</span> <span class="o">=</span> <span class="n">dag</span><span class="o">.</span><span class="n">nodes_on_wire</span><span class="p">(</span><span class="n">wire</span><span class="o">=</span><span class="n">circuit_qubit</span><span class="p">,</span> <span class="n">only_ops</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">qubit_op_idx</span><span class="p">,</span> <span class="n">qubit_op</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">qubit_ops</span><span class="p">):</span>
            <span class="n">gate_depth_encoding</span> <span class="o">=</span> <span class="n">gate_depth_encodings</span><span class="p">[</span><span class="n">qubit_op</span><span class="p">]</span>
            <span class="n">nearest_subcircuit_idx</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
            <span class="n">min_distance</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="s2">&quot;inf&quot;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">subcircuit_idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">subcircuit_gates</span><span class="p">)):</span>
                <span class="n">distance</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="s2">&quot;inf&quot;</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">gate</span> <span class="ow">in</span> <span class="n">subcircuit_gates</span><span class="p">[</span><span class="n">subcircuit_idx</span><span class="p">]:</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">gate</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot; &quot;</span><span class="p">))</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="c1"># Do not compare against single qubit gates</span>
                        <span class="k">continue</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">distance</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span>
                            <span class="n">distance</span><span class="p">,</span>
                            <span class="n">calculate_distance_between_gate</span><span class="p">(</span>
                                <span class="n">gate_A</span><span class="o">=</span><span class="n">gate_depth_encoding</span><span class="p">,</span> <span class="n">gate_B</span><span class="o">=</span><span class="n">gate</span>
                            <span class="p">),</span>
                        <span class="p">)</span>
                <span class="c1"># print(&#39;Distance from %s to subcircuit %d = %f&#39;%(gate_depth_encoding,subcircuit_idx,distance))</span>
                <span class="k">if</span> <span class="n">distance</span> <span class="o">&lt;</span> <span class="n">min_distance</span><span class="p">:</span>
                    <span class="n">min_distance</span> <span class="o">=</span> <span class="n">distance</span>
                    <span class="n">nearest_subcircuit_idx</span> <span class="o">=</span> <span class="n">subcircuit_idx</span>
            <span class="k">assert</span> <span class="n">nearest_subcircuit_idx</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span>
            <span class="n">path_element</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s2">&quot;subcircuit_idx&quot;</span><span class="p">:</span> <span class="n">nearest_subcircuit_idx</span><span class="p">,</span>
                <span class="s2">&quot;subcircuit_qubit&quot;</span><span class="p">:</span> <span class="n">subcircuit_sizes</span><span class="p">[</span><span class="n">nearest_subcircuit_idx</span><span class="p">],</span>
            <span class="p">}</span>
            <span class="k">if</span> <span class="p">(</span>
                <span class="nb">len</span><span class="p">(</span><span class="n">complete_path_map</span><span class="p">[</span><span class="n">circuit_qubit</span><span class="p">])</span> <span class="o">==</span> <span class="mi">0</span>
                <span class="ow">or</span> <span class="n">nearest_subcircuit_idx</span>
                <span class="o">!=</span> <span class="n">complete_path_map</span><span class="p">[</span><span class="n">circuit_qubit</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="s2">&quot;subcircuit_idx&quot;</span><span class="p">]</span>
            <span class="p">):</span>
                <span class="c1"># print(&#39;{} op #{:d} {:s} encoding = {:s}&#39;.format(circuit_qubit,qubit_op_idx,qubit_op.name,gate_depth_encoding),</span>
                <span class="c1"># &#39;belongs in subcircuit %d&#39;%nearest_subcircuit_idx)</span>
                <span class="n">complete_path_map</span><span class="p">[</span><span class="n">circuit_qubit</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">path_element</span><span class="p">)</span>
                <span class="n">subcircuit_sizes</span><span class="p">[</span><span class="n">nearest_subcircuit_idx</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>

            <span class="n">subcircuit_op_nodes</span><span class="p">[</span><span class="n">nearest_subcircuit_idx</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">qubit_op</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">circuit_qubit</span> <span class="ow">in</span> <span class="n">complete_path_map</span><span class="p">:</span>
        <span class="c1"># print(circuit_qubit,&#39;--&gt;&#39;)</span>
        <span class="k">for</span> <span class="n">path_element</span> <span class="ow">in</span> <span class="n">complete_path_map</span><span class="p">[</span><span class="n">circuit_qubit</span><span class="p">]:</span>
            <span class="n">path_element_qubit</span> <span class="o">=</span> <span class="n">QuantumRegister</span><span class="p">(</span>
                <span class="n">size</span><span class="o">=</span><span class="n">subcircuit_sizes</span><span class="p">[</span><span class="n">path_element</span><span class="p">[</span><span class="s2">&quot;subcircuit_idx&quot;</span><span class="p">]],</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;q&quot;</span>
            <span class="p">)[</span><span class="n">path_element</span><span class="p">[</span><span class="s2">&quot;subcircuit_qubit&quot;</span><span class="p">]]</span>
            <span class="n">path_element</span><span class="p">[</span><span class="s2">&quot;subcircuit_qubit&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">path_element_qubit</span>
            <span class="c1"># print(path_element)</span>
    <span class="n">subcircuits</span> <span class="o">=</span> <span class="n">_generate_subcircuits</span><span class="p">(</span>
        <span class="n">subcircuit_op_nodes</span><span class="o">=</span><span class="n">subcircuit_op_nodes</span><span class="p">,</span>
        <span class="n">complete_path_map</span><span class="o">=</span><span class="n">complete_path_map</span><span class="p">,</span>
        <span class="n">subcircuit_sizes</span><span class="o">=</span><span class="n">subcircuit_sizes</span><span class="p">,</span>
        <span class="n">dag</span><span class="o">=</span><span class="n">dag</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="k">return</span> <span class="n">subcircuits</span><span class="p">,</span> <span class="n">complete_path_map</span>


<span class="k">def</span> <span class="nf">_generate_subcircuits</span><span class="p">(</span>
    <span class="n">subcircuit_op_nodes</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">list</span><span class="p">[</span><span class="n">DAGOpNode</span><span class="p">]],</span>
    <span class="n">complete_path_map</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="n">Qubit</span><span class="p">,</span> <span class="nb">list</span><span class="p">[</span><span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span> <span class="o">|</span> <span class="n">Qubit</span><span class="p">]]],</span>
    <span class="n">subcircuit_sizes</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span>
    <span class="n">dag</span><span class="p">:</span> <span class="n">DAGCircuit</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">QuantumCircuit</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generate the subcircuits from given nodes and paths.</span>

<span class="sd">    Called in the subcircuit_parser function to convert the found paths and nodes</span>
<span class="sd">    into actual quantum circuit objects.</span>

<span class="sd">    Args:</span>
<span class="sd">        subcircuit_op_nodes: The nodes of each of the subcircuits</span>
<span class="sd">        complete_path_map: The complete path through the subcircuits</span>
<span class="sd">        subcircuit_sizes: The number of qubits in each of the subcircuits</span>
<span class="sd">        dag: The dag representation of the input quantum circuit</span>

<span class="sd">    Returns:</span>
<span class="sd">        The subcircuits</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">qubit_pointers</span> <span class="o">=</span> <span class="p">{</span><span class="n">x</span><span class="p">:</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">complete_path_map</span><span class="p">}</span>
    <span class="n">subcircuits</span> <span class="o">=</span> <span class="p">[</span><span class="n">QuantumCircuit</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;q&quot;</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">subcircuit_sizes</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">op_node</span> <span class="ow">in</span> <span class="n">dag</span><span class="o">.</span><span class="n">topological_op_nodes</span><span class="p">():</span>
        <span class="n">subcircuit_idx_list</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span>
            <span class="nb">filter</span><span class="p">(</span>
                <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">op_node</span> <span class="ow">in</span> <span class="n">subcircuit_op_nodes</span><span class="p">[</span><span class="n">x</span><span class="p">],</span> <span class="n">subcircuit_op_nodes</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
            <span class="p">)</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">subcircuit_idx_list</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;A node cannot belong to more than one subcircuit.&quot;</span><span class="p">)</span>
        <span class="n">subcircuit_idx</span> <span class="o">=</span> <span class="n">subcircuit_idx_list</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="c1"># print(&#39;{} belongs in subcircuit {:d}&#39;.format(op_node.qargs,subcircuit_idx))</span>
        <span class="n">subcircuit_qargs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">op_node_qarg</span> <span class="ow">in</span> <span class="n">op_node</span><span class="o">.</span><span class="n">qargs</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span>
                <span class="n">complete_path_map</span><span class="p">[</span><span class="n">op_node_qarg</span><span class="p">][</span><span class="n">qubit_pointers</span><span class="p">[</span><span class="n">op_node_qarg</span><span class="p">]][</span>
                    <span class="s2">&quot;subcircuit_idx&quot;</span>
                <span class="p">]</span>
                <span class="o">!=</span> <span class="n">subcircuit_idx</span>
            <span class="p">):</span>
                <span class="n">qubit_pointers</span><span class="p">[</span><span class="n">op_node_qarg</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">path_element</span> <span class="o">=</span> <span class="n">complete_path_map</span><span class="p">[</span><span class="n">op_node_qarg</span><span class="p">][</span><span class="n">qubit_pointers</span><span class="p">[</span><span class="n">op_node_qarg</span><span class="p">]]</span>
            <span class="k">assert</span> <span class="n">path_element</span><span class="p">[</span><span class="s2">&quot;subcircuit_idx&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="n">subcircuit_idx</span>
            <span class="n">subcircuit_qargs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">path_element</span><span class="p">[</span><span class="s2">&quot;subcircuit_qubit&quot;</span><span class="p">])</span>
        <span class="c1"># print(&#39;--&gt;&#39;,subcircuit_qargs)</span>

        <span class="c1"># mypy doesn&#39;t recognize QuantumCircuit as being an Iterable, so we ignore</span>
        <span class="n">subcircuits</span><span class="p">[</span><span class="n">subcircuit_idx</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>  <span class="c1"># type: ignore</span>
            <span class="n">instruction</span><span class="o">=</span><span class="n">op_node</span><span class="o">.</span><span class="n">op</span><span class="p">,</span> <span class="n">qargs</span><span class="o">=</span><span class="n">subcircuit_qargs</span><span class="p">,</span> <span class="n">cargs</span><span class="o">=</span><span class="kc">None</span>
        <span class="p">)</span>
    <span class="k">return</span> <span class="n">subcircuits</span>


<span class="k">def</span> <span class="nf">_get_counter</span><span class="p">(</span>
    <span class="n">subcircuits</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">QuantumCircuit</span><span class="p">],</span>
    <span class="n">O_rho_pairs</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span> <span class="o">|</span> <span class="n">Qubit</span><span class="p">],</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span> <span class="o">|</span> <span class="n">Qubit</span><span class="p">]]],</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Create information regarding each of the subcircuit parameters (qubits, width, etc.).</span>

<span class="sd">    Args:</span>
<span class="sd">        subcircuits: The list of subcircuits</span>
<span class="sd">        O_rho_pairs: The pairs for each qubit path as generated in the _get_pairs function</span>

<span class="sd">    Returns:</span>
<span class="sd">        The resulting dictionary with all parameter information</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">counter</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">subcircuit_idx</span><span class="p">,</span> <span class="n">subcircuit</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">subcircuits</span><span class="p">):</span>
        <span class="n">counter</span><span class="p">[</span><span class="n">subcircuit_idx</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;effective&quot;</span><span class="p">:</span> <span class="n">subcircuit</span><span class="o">.</span><span class="n">num_qubits</span><span class="p">,</span>
            <span class="s2">&quot;rho&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
            <span class="s2">&quot;O&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
            <span class="s2">&quot;d&quot;</span><span class="p">:</span> <span class="n">subcircuit</span><span class="o">.</span><span class="n">num_qubits</span><span class="p">,</span>
            <span class="s2">&quot;depth&quot;</span><span class="p">:</span> <span class="n">subcircuit</span><span class="o">.</span><span class="n">depth</span><span class="p">(),</span>
            <span class="s2">&quot;size&quot;</span><span class="p">:</span> <span class="n">subcircuit</span><span class="o">.</span><span class="n">size</span><span class="p">(),</span>
        <span class="p">}</span>
    <span class="k">for</span> <span class="n">pair</span> <span class="ow">in</span> <span class="n">O_rho_pairs</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">pair</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;O_rho_pairs must be length 2: </span><span class="si">{</span><span class="n">pair</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">O_qubit</span> <span class="o">=</span> <span class="n">pair</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">rho_qubit</span> <span class="o">=</span> <span class="n">pair</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">counter</span><span class="p">[</span><span class="n">O_qubit</span><span class="p">[</span><span class="s2">&quot;subcircuit_idx&quot;</span><span class="p">]][</span><span class="s2">&quot;effective&quot;</span><span class="p">]</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="n">counter</span><span class="p">[</span><span class="n">O_qubit</span><span class="p">[</span><span class="s2">&quot;subcircuit_idx&quot;</span><span class="p">]][</span><span class="s2">&quot;O&quot;</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">counter</span><span class="p">[</span><span class="n">rho_qubit</span><span class="p">[</span><span class="s2">&quot;subcircuit_idx&quot;</span><span class="p">]][</span><span class="s2">&quot;rho&quot;</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">counter</span>


<span class="k">def</span> <span class="nf">_cost_estimate</span><span class="p">(</span><span class="n">counter</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Estimate the cost of processing the subcircuits.</span>

<span class="sd">    Args:</span>
<span class="sd">        counter: Dictionary containing information for each of the subcircuits</span>

<span class="sd">    Returns:</span>
<span class="sd">        The estimated cost for classical processing</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">num_cuts</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">([</span><span class="n">counter</span><span class="p">[</span><span class="n">subcircuit_idx</span><span class="p">][</span><span class="s2">&quot;rho&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="n">subcircuit_idx</span> <span class="ow">in</span> <span class="n">counter</span><span class="p">])</span>
    <span class="n">subcircuit_indices</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">counter</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
    <span class="n">num_effective_qubits_list</span> <span class="o">=</span> <span class="p">[</span>
        <span class="n">counter</span><span class="p">[</span><span class="n">subcircuit_idx</span><span class="p">][</span><span class="s2">&quot;effective&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="n">subcircuit_idx</span> <span class="ow">in</span> <span class="n">subcircuit_indices</span>
    <span class="p">]</span>
    <span class="n">num_effective_qubits</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span>
        <span class="o">*</span><span class="nb">sorted</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">num_effective_qubits_list</span><span class="p">,</span> <span class="n">subcircuit_indices</span><span class="p">))</span>
    <span class="p">)</span>
    <span class="n">classical_cost</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">accumulated_kron_len</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">**</span> <span class="n">num_effective_qubits</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">effective</span> <span class="ow">in</span> <span class="n">num_effective_qubits</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
        <span class="n">accumulated_kron_len</span> <span class="o">*=</span> <span class="mi">2</span><span class="o">**</span><span class="n">effective</span>
        <span class="n">classical_cost</span> <span class="o">+=</span> <span class="n">accumulated_kron_len</span>
    <span class="n">classical_cost</span> <span class="o">*=</span> <span class="mi">4</span><span class="o">**</span><span class="n">num_cuts</span>
    <span class="k">return</span> <span class="n">classical_cost</span>


<span class="k">def</span> <span class="nf">_get_pairs</span><span class="p">(</span>
    <span class="n">complete_path_map</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="n">Qubit</span><span class="p">,</span> <span class="nb">list</span><span class="p">[</span><span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span> <span class="o">|</span> <span class="n">Qubit</span><span class="p">]]]</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span> <span class="o">|</span> <span class="n">Qubit</span><span class="p">],</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span> <span class="o">|</span> <span class="n">Qubit</span><span class="p">]]]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Get all pairs through each path.</span>

<span class="sd">    Iterates through the path for each of the qubits and keeps track of the</span>
<span class="sd">    each pair of neigbors.</span>

<span class="sd">    Args:</span>
<span class="sd">        complete_path_map: The dictionary containing all path information</span>

<span class="sd">    Returns:</span>
<span class="sd">        All pairs for each of the qubit paths</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">O_rho_pairs</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">input_qubit</span> <span class="ow">in</span> <span class="n">complete_path_map</span><span class="p">:</span>
        <span class="n">path</span> <span class="o">=</span> <span class="n">complete_path_map</span><span class="p">[</span><span class="n">input_qubit</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">path</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">path_ctr</span><span class="p">,</span> <span class="n">item</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">path</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]):</span>
                <span class="n">O_qubit_tuple</span> <span class="o">=</span> <span class="n">item</span>
                <span class="n">rho_qubit_tuple</span> <span class="o">=</span> <span class="n">path</span><span class="p">[</span><span class="n">path_ctr</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
                <span class="n">O_rho_pairs</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">O_qubit_tuple</span><span class="p">,</span> <span class="n">rho_qubit_tuple</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">O_rho_pairs</span>


<span class="k">def</span> <span class="nf">_circuit_stripping</span><span class="p">(</span><span class="n">circuit</span><span class="p">:</span> <span class="n">QuantumCircuit</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">QuantumCircuit</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Remove all single qubit and barrier type gates.</span>

<span class="sd">    Args:</span>
<span class="sd">        circuit: The circuit to strip</span>

<span class="sd">    Returns:</span>
<span class="sd">        The stripped circuit</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Remove all single qubit gates and barriers in the circuit</span>
    <span class="n">dag</span> <span class="o">=</span> <span class="n">circuit_to_dag</span><span class="p">(</span><span class="n">circuit</span><span class="p">)</span>
    <span class="n">stripped_dag</span> <span class="o">=</span> <span class="n">DAGCircuit</span><span class="p">()</span>
    <span class="p">[</span><span class="n">stripped_dag</span><span class="o">.</span><span class="n">add_qreg</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">circuit</span><span class="o">.</span><span class="n">qregs</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">vertex</span> <span class="ow">in</span> <span class="n">dag</span><span class="o">.</span><span class="n">topological_op_nodes</span><span class="p">():</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">vertex</span><span class="o">.</span><span class="n">qargs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">vertex</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">name</span> <span class="o">!=</span> <span class="s2">&quot;barrier&quot;</span><span class="p">:</span>
            <span class="n">stripped_dag</span><span class="o">.</span><span class="n">apply_operation_back</span><span class="p">(</span><span class="n">op</span><span class="o">=</span><span class="n">vertex</span><span class="o">.</span><span class="n">op</span><span class="p">,</span> <span class="n">qargs</span><span class="o">=</span><span class="n">vertex</span><span class="o">.</span><span class="n">qargs</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">dag_to_circuit</span><span class="p">(</span><span class="n">stripped_dag</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_read_circuit</span><span class="p">(</span>
    <span class="n">circuit</span><span class="p">:</span> <span class="n">QuantumCircuit</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">list</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]],</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Read the input circuit to a graph based representation for the MIP model.</span>

<span class="sd">    Args:</span>
<span class="sd">        circuit: A stripped circuit to be converted into a DAG like representation</span>

<span class="sd">    Returns:</span>
<span class="sd">        A tuple containing the number of vertices, edge list, vertex to vertex id mapping,</span>
<span class="sd">        and vertex id to vertex mapping.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">dag</span> <span class="o">=</span> <span class="n">circuit_to_dag</span><span class="p">(</span><span class="n">circuit</span><span class="p">)</span>
    <span class="n">edges</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">node_name_ids</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">id_node_names</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">vertex_ids</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">curr_node_id</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">qubit_gate_counter</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">qubit</span> <span class="ow">in</span> <span class="n">dag</span><span class="o">.</span><span class="n">qubits</span><span class="p">:</span>
        <span class="n">qubit_gate_counter</span><span class="p">[</span><span class="n">qubit</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">vertex</span> <span class="ow">in</span> <span class="n">dag</span><span class="o">.</span><span class="n">topological_op_nodes</span><span class="p">():</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">vertex</span><span class="o">.</span><span class="n">qargs</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;vertex does not have 2 qargs!&quot;</span><span class="p">)</span>
        <span class="n">arg0</span><span class="p">,</span> <span class="n">arg1</span> <span class="o">=</span> <span class="n">vertex</span><span class="o">.</span><span class="n">qargs</span>
        <span class="n">vertex_name</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">%s</span><span class="s2">[</span><span class="si">%d</span><span class="s2">]</span><span class="si">%d</span><span class="s2"> </span><span class="si">%s</span><span class="s2">[</span><span class="si">%d</span><span class="s2">]</span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span>
            <span class="n">circuit</span><span class="o">.</span><span class="n">find_bit</span><span class="p">(</span><span class="n">arg0</span><span class="p">)</span><span class="o">.</span><span class="n">registers</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
            <span class="n">circuit</span><span class="o">.</span><span class="n">find_bit</span><span class="p">(</span><span class="n">arg0</span><span class="p">)</span><span class="o">.</span><span class="n">index</span><span class="p">,</span>
            <span class="n">qubit_gate_counter</span><span class="p">[</span><span class="n">arg0</span><span class="p">],</span>
            <span class="n">circuit</span><span class="o">.</span><span class="n">find_bit</span><span class="p">(</span><span class="n">arg1</span><span class="p">)</span><span class="o">.</span><span class="n">registers</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
            <span class="n">circuit</span><span class="o">.</span><span class="n">find_bit</span><span class="p">(</span><span class="n">arg1</span><span class="p">)</span><span class="o">.</span><span class="n">index</span><span class="p">,</span>
            <span class="n">qubit_gate_counter</span><span class="p">[</span><span class="n">arg1</span><span class="p">],</span>
        <span class="p">)</span>
        <span class="n">qubit_gate_counter</span><span class="p">[</span><span class="n">arg0</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">qubit_gate_counter</span><span class="p">[</span><span class="n">arg1</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="c1"># print(vertex.op.label,vertex_name,curr_node_id)</span>
        <span class="k">if</span> <span class="n">vertex_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">node_name_ids</span> <span class="ow">and</span> <span class="nb">id</span><span class="p">(</span><span class="n">vertex</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">vertex_ids</span><span class="p">:</span>
            <span class="n">node_name_ids</span><span class="p">[</span><span class="n">vertex_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">curr_node_id</span>
            <span class="n">id_node_names</span><span class="p">[</span><span class="n">curr_node_id</span><span class="p">]</span> <span class="o">=</span> <span class="n">vertex_name</span>
            <span class="n">vertex_ids</span><span class="p">[</span><span class="nb">id</span><span class="p">(</span><span class="n">vertex</span><span class="p">)]</span> <span class="o">=</span> <span class="n">curr_node_id</span>
            <span class="n">curr_node_id</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="k">for</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">dag</span><span class="o">.</span><span class="n">edges</span><span class="p">():</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">DAGOpNode</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">DAGOpNode</span><span class="p">):</span>
            <span class="n">u_id</span> <span class="o">=</span> <span class="n">vertex_ids</span><span class="p">[</span><span class="nb">id</span><span class="p">(</span><span class="n">u</span><span class="p">)]</span>
            <span class="n">v_id</span> <span class="o">=</span> <span class="n">vertex_ids</span><span class="p">[</span><span class="nb">id</span><span class="p">(</span><span class="n">v</span><span class="p">)]</span>
            <span class="n">edges</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">u_id</span><span class="p">,</span> <span class="n">v_id</span><span class="p">))</span>

    <span class="n">n_vertices</span> <span class="o">=</span> <span class="n">dag</span><span class="o">.</span><span class="n">size</span><span class="p">()</span>

    <span class="k">return</span> <span class="n">n_vertices</span><span class="p">,</span> <span class="n">edges</span><span class="p">,</span> <span class="n">node_name_ids</span><span class="p">,</span> <span class="n">id_node_names</span>
</pre></div>

          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../../../index.html">Circuit Knitting Toolbox</a></h1>








<h3>Navigation</h3>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../install.html">Installation Instructions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../circuit_cutting/tutorials/index.html">Circuit Cutting Tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../circuit_cutting/explanation/index.html">Circuit Cutting Explanatory Material</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../circuit_cutting/how-tos/index.html">Circuit Cutting How-To Guides</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../circuit_cutting/cutqc/index.html">CutQC (legacy circuit cutting implementation)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../entanglement_forging/tutorials/index.html">Entanglement Forging Tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../entanglement_forging/explanation/index.html">Entanglement Forging Explanatory Material</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../entanglement_forging/how-tos/index.html">Entanglement Forging How-To Guides</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../apidocs/index.html">API References</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../release-notes.html">Release Notes</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../../index.html">Documentation overview</a><ul>
  <li><a href="../../../index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2023.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 7.0.1</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.13</a>
      
    </div>

    

    
  </body>
</html>