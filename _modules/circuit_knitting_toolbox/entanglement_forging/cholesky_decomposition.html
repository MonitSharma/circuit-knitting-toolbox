
<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>circuit_knitting_toolbox.entanglement_forging.cholesky_decomposition &#8212; Circuit Knitting Toolbox 0.0.0 documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/alabaster.css" />
    <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
    <script src="../../../_static/jquery.js"></script>
    <script src="../../../_static/underscore.js"></script>
    <script src="../../../_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="../../../_static/doctools.js"></script>
    <script src="../../../_static/sphinx_highlight.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
   
  <link rel="stylesheet" href="../../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <h1>Source code for circuit_knitting_toolbox.entanglement_forging.cholesky_decomposition</h1><div class="highlight"><pre>
<span></span><span class="c1"># This code is a Qiskit project.</span>

<span class="c1"># (C) Copyright IBM 2022.</span>

<span class="c1"># This code is licensed under the Apache License, Version 2.0. You may</span>
<span class="c1"># obtain a copy of this license in the LICENSE.txt file in the root directory</span>
<span class="c1"># of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.</span>
<span class="c1"># Any modifications or derivative works of this code must retain this</span>
<span class="c1"># copyright notice, and modified files need to carry a notice indicating</span>
<span class="c1"># that they have been altered from the originals.</span>

<span class="sd">&quot;&quot;&quot;File containing the EntanglementForgingGroundStateSolver class and associated functions.&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">,</span> <span class="n">Tuple</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">nptyping</span> <span class="kn">import</span> <span class="n">Float</span><span class="p">,</span> <span class="n">Int</span><span class="p">,</span> <span class="n">NDArray</span><span class="p">,</span> <span class="n">Shape</span>
<span class="kn">from</span> <span class="nn">qiskit.opflow</span> <span class="kn">import</span> <span class="n">ListOp</span><span class="p">,</span> <span class="n">PauliSumOp</span>
<span class="kn">from</span> <span class="nn">qiskit.quantum_info</span> <span class="kn">import</span> <span class="n">Pauli</span>
<span class="kn">from</span> <span class="nn">qiskit_nature.converters.second_quantization</span> <span class="kn">import</span> <span class="n">QubitConverter</span>
<span class="kn">from</span> <span class="nn">qiskit_nature.drivers.second_quantization</span> <span class="kn">import</span> <span class="n">ElectronicStructureDriver</span>
<span class="kn">from</span> <span class="nn">qiskit_nature.mappers.second_quantization</span> <span class="kn">import</span> <span class="n">JordanWignerMapper</span>
<span class="kn">from</span> <span class="nn">qiskit_nature.problems.second_quantization</span> <span class="kn">import</span> <span class="n">ElectronicStructureProblem</span>
<span class="kn">from</span> <span class="nn">qiskit_nature.properties.second_quantization.electronic.bases</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">ElectronicBasis</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">qiskit_nature.properties.second_quantization.electronic.integrals</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">IntegralProperty</span><span class="p">,</span>
    <span class="n">OneBodyElectronicIntegrals</span><span class="p">,</span>
    <span class="n">TwoBodyElectronicIntegrals</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">quantum_serverless</span> <span class="kn">import</span> <span class="n">get</span><span class="p">,</span> <span class="n">run_qiskit_remote</span>

<span class="kn">from</span> <span class="nn">.entanglement_forging_ansatz</span> <span class="kn">import</span> <span class="n">EntanglementForgingAnsatz</span>
<span class="kn">from</span> <span class="nn">.entanglement_forging_operator</span> <span class="kn">import</span> <span class="n">EntanglementForgingOperator</span>
<span class="kn">from</span> <span class="nn">.entanglement_forging_ansatz</span> <span class="kn">import</span> <span class="n">EntanglementForgingAnsatz</span>


<span class="n">SingleBodyIntegrals</span> <span class="o">=</span> <span class="n">NDArray</span><span class="p">[</span><span class="n">Shape</span><span class="p">[</span><span class="s2">&quot;N, N&quot;</span><span class="p">],</span> <span class="n">Float</span><span class="p">]</span>
<span class="n">Matrix</span> <span class="o">=</span> <span class="n">NDArray</span><span class="p">[</span><span class="n">Shape</span><span class="p">[</span><span class="s2">&quot;N, N&quot;</span><span class="p">],</span> <span class="n">Float</span><span class="p">]</span>
<span class="n">TwoBodyIntegrals</span> <span class="o">=</span> <span class="n">NDArray</span><span class="p">[</span><span class="n">Shape</span><span class="p">[</span><span class="s2">&quot;N, N, N, N&quot;</span><span class="p">],</span> <span class="n">Float</span><span class="p">]</span>


<span class="nd">@run_qiskit_remote</span><span class="p">()</span>
<span class="k">def</span> <span class="nf">get_cholesky_op</span><span class="p">(</span>
    <span class="n">l_op</span><span class="p">:</span> <span class="n">NDArray</span><span class="p">,</span> <span class="n">g</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">converter</span><span class="p">:</span> <span class="n">QubitConverter</span><span class="p">,</span> <span class="n">opname</span><span class="p">:</span> <span class="nb">str</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">PauliSumOp</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert a two-body term into a cholesky operator.</span>

<span class="sd">    Args:</span>
<span class="sd">        - l_op: Two body integrals</span>
<span class="sd">        - g: integral index</span>
<span class="sd">        - converter: Qubit converter to be used</span>
<span class="sd">        - opname: Prefix for output cholesky operator name</span>

<span class="sd">    Returns:</span>
<span class="sd">        - cholesky_operator: The converted operator</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># This will suppress a warning about an upcoming change in Qiskit Nature</span>
    <span class="kn">from</span> <span class="nn">qiskit_nature.settings</span> <span class="kn">import</span> <span class="n">settings</span>

    <span class="n">settings</span><span class="o">.</span><span class="n">dict_aux_operators</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="n">cholesky_int</span> <span class="o">=</span> <span class="n">OneBodyElectronicIntegrals</span><span class="p">(</span>
        <span class="n">basis</span><span class="o">=</span><span class="n">ElectronicBasis</span><span class="o">.</span><span class="n">SO</span><span class="p">,</span> <span class="n">matrices</span><span class="o">=</span><span class="n">l_op</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">g</span><span class="p">]</span>
    <span class="p">)</span>
    <span class="n">cholesky_property</span> <span class="o">=</span> <span class="n">IntegralProperty</span><span class="p">(</span><span class="s2">&quot;cholesky_op&quot;</span><span class="p">,</span> <span class="p">[</span><span class="n">cholesky_int</span><span class="p">])</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">cholesky_property</span><span class="o">.</span><span class="n">second_q_ops</span><span class="p">(),</span> <span class="nb">dict</span><span class="p">):</span>
        <span class="n">cholesky_op</span> <span class="o">=</span> <span class="n">converter</span><span class="o">.</span><span class="n">convert</span><span class="p">(</span><span class="n">cholesky_property</span><span class="o">.</span><span class="n">second_q_ops</span><span class="p">()[</span><span class="s2">&quot;cholesky_op&quot;</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">cholesky_op</span> <span class="o">=</span> <span class="n">converter</span><span class="o">.</span><span class="n">convert</span><span class="p">(</span><span class="n">cholesky_property</span><span class="o">.</span><span class="n">second_q_ops</span><span class="p">()[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">cholesky_op</span><span class="o">.</span><span class="n">_name</span> <span class="o">=</span> <span class="n">opname</span> <span class="o">+</span> <span class="s2">&quot;_chol&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">cholesky_op</span>


<div class="viewcode-block" id="cholesky_decomposition"><a class="viewcode-back" href="../../../stubs/circuit_knitting_toolbox.entanglement_forging.cholesky_decomposition.html#circuit_knitting_toolbox.entanglement_forging.cholesky_decomposition">[docs]</a><span class="k">def</span> <span class="nf">cholesky_decomposition</span><span class="p">(</span>
    <span class="n">problem</span><span class="p">:</span> <span class="n">ElectronicStructureProblem</span><span class="p">,</span>
    <span class="n">orbitals_to_reduce</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">ListOp</span><span class="p">,</span> <span class="nb">float</span><span class="p">]:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Construct the decomposed Hamiltonian from an input ``ElectronicStructureProblem``.</span>

<span class="sd">    Args:</span>
<span class="sd">        - problem (ElectronicStructureProblem): An ``ElectronicStructureProblem`` from which the decomposed Hamiltonian will be</span>
<span class="sd">            calculated.</span>
<span class="sd">        - orbitals_to_reduce (Optional[Sequence[int]]): A list of orbital indices to remove from the problem before decomposition.</span>

<span class="sd">    Returns:</span>
<span class="sd">        - Tuple containing</span>
<span class="sd">            - cholesky_operator (ListOp): A list of operators representing the decomposed Hamiltonian.</span>
<span class="sd">              shape: [single-body hamiltonian, cholesky_0, ..., cholesky_N]</span>
<span class="sd">            - freeze_shift (float): An energy shift resulting from the decomposition. This shift should be re-applied after</span>
<span class="sd">              calculating properties of the decomposed operator (i.e. ground state energy).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Store the ElectronicStructureProblem</span>
    <span class="n">problem</span><span class="o">.</span><span class="n">second_q_ops</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">problem</span><span class="o">.</span><span class="n">grouped_property_transformed</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span>
            <span class="s2">&quot;There was a problem retrieving the grouped properties from the ElectronicStructureProblem.&quot;</span>
        <span class="p">)</span>
    <span class="k">if</span> <span class="n">problem</span><span class="o">.</span><span class="n">driver</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s2">&quot;The ElectronicStructureProblem has no driver.&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">problem</span><span class="o">.</span><span class="n">driver</span><span class="p">,</span> <span class="n">ElectronicStructureDriver</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span>
            <span class="s2">&quot;The ElectronicStructureProblem&#39;s driver should be an instance of ElectronicStructureDriver.&quot;</span>
        <span class="p">)</span>

    <span class="n">electronic_basis_transform</span> <span class="o">=</span> <span class="n">problem</span><span class="o">.</span><span class="n">grouped_property_transformed</span><span class="o">.</span><span class="n">get_property</span><span class="p">(</span>
        <span class="s2">&quot;ElectronicBasisTransform&quot;</span>
    <span class="p">)</span>
    <span class="k">if</span> <span class="n">electronic_basis_transform</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span>
            <span class="s2">&quot;There was a problem retrieving the ElectronicBasisTransform property from the ElectronicStructureProblem.&quot;</span>
        <span class="p">)</span>

    <span class="n">electronic_energy</span> <span class="o">=</span> <span class="n">problem</span><span class="o">.</span><span class="n">grouped_property_transformed</span><span class="o">.</span><span class="n">get_property</span><span class="p">(</span>
        <span class="s2">&quot;ElectronicEnergy&quot;</span>
    <span class="p">)</span>
    <span class="k">if</span> <span class="n">electronic_energy</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span>
            <span class="s2">&quot;There was a problem retrieving the ElectronicEnergy property from the ElectronicStructureProblem.&quot;</span>
        <span class="p">)</span>

    <span class="n">particle_number</span> <span class="o">=</span> <span class="n">problem</span><span class="o">.</span><span class="n">grouped_property_transformed</span><span class="o">.</span><span class="n">get_property</span><span class="p">(</span>
        <span class="s2">&quot;ParticleNumber&quot;</span>
    <span class="p">)</span>
    <span class="k">if</span> <span class="n">particle_number</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span>
            <span class="s2">&quot;There was a problem retrieving the ParticleNumber property from the ElectronicStructureProblem.&quot;</span>
        <span class="p">)</span>

    <span class="c1"># Get data for generating the cholesky decomposition</span>
    <span class="n">mo_coeff</span><span class="p">:</span> <span class="n">Matrix</span> <span class="o">=</span> <span class="n">electronic_basis_transform</span><span class="o">.</span><span class="n">coeff_alpha</span>
    <span class="n">hcore</span><span class="p">:</span> <span class="n">SingleBodyIntegrals</span> <span class="o">=</span> <span class="n">electronic_energy</span><span class="o">.</span><span class="n">get_electronic_integral</span><span class="p">(</span>
        <span class="n">ElectronicBasis</span><span class="o">.</span><span class="n">AO</span><span class="p">,</span> <span class="mi">1</span>
    <span class="p">)</span><span class="o">.</span><span class="n">_matrices</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">eri</span><span class="p">:</span> <span class="n">TwoBodyIntegrals</span> <span class="o">=</span> <span class="n">electronic_energy</span><span class="o">.</span><span class="n">get_electronic_integral</span><span class="p">(</span>
        <span class="n">ElectronicBasis</span><span class="o">.</span><span class="n">AO</span><span class="p">,</span> <span class="mi">2</span>
    <span class="p">)</span><span class="o">.</span><span class="n">_matrices</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">num_alpha</span> <span class="o">=</span> <span class="n">particle_number</span><span class="o">.</span><span class="n">num_alpha</span>

    <span class="c1"># Store the reduced orbitals as virtual and occupied lists</span>
    <span class="k">if</span> <span class="n">orbitals_to_reduce</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">orbitals_to_reduce</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">orbitals_to_reduce_dict</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span>
        <span class="nb">str</span><span class="p">,</span> <span class="n">NDArray</span><span class="p">[</span><span class="n">Shape</span><span class="p">[</span><span class="s2">&quot;*&quot;</span><span class="p">],</span> <span class="n">Int</span><span class="p">]</span>
    <span class="p">]</span> <span class="o">=</span> <span class="n">_get_orbitals_to_reduce</span><span class="p">(</span><span class="n">orbitals_to_reduce</span><span class="p">,</span> <span class="n">num_alpha</span><span class="p">)</span>

    <span class="c1"># Hold fields used to calculate the final energy shift</span>
    <span class="c1"># Freeze shift will be calculated during decomposition</span>
    <span class="n">freeze_shift</span> <span class="o">=</span> <span class="mf">0.0</span>
    <span class="n">nuclear_repulsion_energy</span> <span class="o">=</span> <span class="n">electronic_energy</span><span class="o">.</span><span class="n">nuclear_repulsion_energy</span>

    <span class="n">h_1_op</span><span class="p">,</span> <span class="n">h_chol_ops</span><span class="p">,</span> <span class="n">freeze_shift</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">_get_fermionic_ops_with_cholesky</span><span class="p">(</span>
        <span class="n">mo_coeff</span><span class="p">,</span>
        <span class="n">hcore</span><span class="p">,</span>
        <span class="n">eri</span><span class="p">,</span>
        <span class="n">opname</span><span class="o">=</span><span class="s2">&quot;H&quot;</span><span class="p">,</span>
        <span class="n">halve_transformed_h2</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">occupied_orbitals_to_reduce</span><span class="o">=</span><span class="n">orbitals_to_reduce_dict</span><span class="p">[</span><span class="s2">&quot;occupied&quot;</span><span class="p">],</span>
        <span class="n">virtual_orbitals_to_reduce</span><span class="o">=</span><span class="n">orbitals_to_reduce_dict</span><span class="p">[</span><span class="s2">&quot;virtual&quot;</span><span class="p">],</span>
    <span class="p">)</span>

    <span class="n">op_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">h_1_op</span><span class="p">]</span> <span class="o">+</span> <span class="n">h_chol_ops</span>
    <span class="n">operator</span> <span class="o">=</span> <span class="n">ListOp</span><span class="p">(</span><span class="n">op_list</span><span class="p">)</span>

    <span class="n">energy_shift</span> <span class="o">=</span> <span class="n">freeze_shift</span> <span class="o">+</span> <span class="n">nuclear_repulsion_energy</span>

    <span class="k">return</span> <span class="n">operator</span><span class="p">,</span> <span class="n">energy_shift</span></div>


<div class="viewcode-block" id="convert_cholesky_operator"><a class="viewcode-back" href="../../../stubs/circuit_knitting_toolbox.entanglement_forging.convert_cholesky_operator.html#circuit_knitting_toolbox.entanglement_forging.convert_cholesky_operator">[docs]</a><span class="k">def</span> <span class="nf">convert_cholesky_operator</span><span class="p">(</span>
    <span class="n">operator</span><span class="p">:</span> <span class="n">ListOp</span><span class="p">,</span>
    <span class="n">ansatz</span><span class="p">:</span> <span class="n">EntanglementForgingAnsatz</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">EntanglementForgingOperator</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert the Cholesky operator (ListOp) into the entanglement forging format.</span>

<span class="sd">    Args:</span>
<span class="sd">        - operator: A `ListOp` containing the single-body Hamiltonian followed</span>
<span class="sd">            by the Cholesky operators.</span>
<span class="sd">            shape: [single-body hamiltonian, cholesky_0, ..., cholesky_N]</span>
<span class="sd">        - ansatz:</span>
<span class="sd">            The ansatz for which to compute expectation values of operator. The</span>
<span class="sd">            `EntanglementForgingAnsatz` also contains the bitstrings for each subsystem..</span>

<span class="sd">    Returns:</span>
<span class="sd">        - forged_operator: An `EntanglementForgingOperator` object describing the</span>
<span class="sd">            decomposed operator.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">calculate_hybrid_cross_terms</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">ansatz</span><span class="o">.</span><span class="n">bitstrings_u</span><span class="p">))</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span>
        <span class="n">ansatz</span><span class="o">.</span><span class="n">bitstrings_u</span>
    <span class="p">)</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">ansatz</span><span class="o">.</span><span class="n">bitstrings_v</span><span class="p">))</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">ansatz</span><span class="o">.</span><span class="n">bitstrings_v</span><span class="p">)</span>

    <span class="n">op1</span> <span class="o">=</span> <span class="n">operator</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">cholesky_ops</span> <span class="o">=</span> <span class="n">operator</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>

    <span class="c1"># The block below calculate the Pauli-pair prefactors w_ij and returns</span>
    <span class="c1"># them as a dictionary</span>
    <span class="n">tensor_paulis</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    <span class="n">superpos_paulis</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    <span class="n">paulis_each_op</span> <span class="o">=</span> <span class="p">[</span>
        <span class="p">{</span>
            <span class="n">label</span><span class="p">:</span> <span class="n">weight</span>
            <span class="k">for</span> <span class="n">label</span><span class="p">,</span> <span class="n">weight</span> <span class="ow">in</span> <span class="n">op</span><span class="o">.</span><span class="n">primitive</span><span class="o">.</span><span class="n">to_list</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">weight</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span>
        <span class="p">}</span>
        <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="p">[</span><span class="n">op1</span><span class="p">]</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">cholesky_ops</span><span class="p">)</span>
    <span class="p">]</span>

    <span class="c1"># Gather the elements in the Pauli basis for tensor and superpos terms</span>
    <span class="n">paulis_each_op</span> <span class="o">=</span> <span class="p">[</span><span class="n">paulis_each_op</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">+</span> <span class="p">[</span><span class="n">p</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">paulis_each_op</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="k">if</span> <span class="n">p</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">op_idx</span><span class="p">,</span> <span class="n">paulis_this_op</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">paulis_each_op</span><span class="p">):</span>
        <span class="n">pnames</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">paulis_this_op</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="n">tensor_paulis</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">pnames</span><span class="p">)</span>

        <span class="c1"># If hybrid terms are needed, the superposition basis includes</span>
        <span class="c1"># terms from the single body Hamiltonian.</span>
        <span class="k">if</span> <span class="n">calculate_hybrid_cross_terms</span> <span class="ow">or</span> <span class="n">op_idx</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">superpos_paulis</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">pnames</span><span class="p">)</span>

    <span class="c1"># ensure Identity string is represented since we will need it</span>
    <span class="n">identity_string</span> <span class="o">=</span> <span class="s2">&quot;I&quot;</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">pnames</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">tensor_paulis</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">identity_string</span><span class="p">)</span>
    <span class="n">superpos_paulis</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">identity_string</span><span class="p">)</span>

    <span class="c1"># Sort the Pauli bases</span>
    <span class="n">tensor_pauli_names</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">tensor_paulis</span><span class="p">))</span>
    <span class="n">superpos_pauli_names</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">superpos_paulis</span><span class="p">))</span>

    <span class="c1"># Map the tensor Pauli terms to their place in the tensor index</span>
    <span class="n">pauli_ordering_for_tensor_states</span> <span class="o">=</span> <span class="p">{</span>
        <span class="n">pname</span><span class="p">:</span> <span class="n">idx</span> <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">pname</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">tensor_pauli_names</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="c1"># Map the superpos Pauli basis terms to their place in the superpos index</span>
    <span class="n">pauli_ordering_for_superpos_states</span> <span class="o">=</span> <span class="p">{</span>
        <span class="n">pname</span><span class="p">:</span> <span class="n">idx</span> <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">pname</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">superpos_pauli_names</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="c1"># Create arrays for the tensor and superpos weights, respectively</span>
    <span class="n">w_ij</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">tensor_pauli_names</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">tensor_pauli_names</span><span class="p">)))</span>
    <span class="n">w_ab</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">superpos_pauli_names</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">superpos_pauli_names</span><span class="p">)))</span>

    <span class="c1"># Processes the non-Cholesky operator</span>
    <span class="n">identity_idx</span> <span class="o">=</span> <span class="n">pauli_ordering_for_tensor_states</span><span class="p">[</span><span class="n">identity_string</span><span class="p">]</span>
    <span class="n">identity_idx_superpos</span> <span class="o">=</span> <span class="n">pauli_ordering_for_tensor_states</span><span class="p">[</span><span class="n">identity_string</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">pname_i</span><span class="p">,</span> <span class="n">w_i</span> <span class="ow">in</span> <span class="n">paulis_each_op</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">pauli_ordering_for_tensor_states</span><span class="p">[</span><span class="n">pname_i</span><span class="p">]</span>
        <span class="n">w_ij</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">identity_idx</span><span class="p">]</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">w_i</span><span class="p">)</span>  <span class="c1"># H_spin-up</span>
        <span class="n">w_ij</span><span class="p">[</span><span class="n">identity_idx</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">w_i</span><span class="p">)</span>  <span class="c1"># H_spin-down</span>

        <span class="c1"># In the special case where bn=bm, we need terms from the</span>
        <span class="c1"># single body system represented in the cross terms</span>
        <span class="k">if</span> <span class="n">calculate_hybrid_cross_terms</span><span class="p">:</span>
            <span class="n">w_ab</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">identity_idx_superpos</span><span class="p">]</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">w_i</span><span class="p">)</span>
            <span class="n">w_ab</span><span class="p">[</span><span class="n">identity_idx_superpos</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">w_i</span><span class="p">)</span>

    <span class="c1"># Processes the Cholesky operators (indexed by gamma)</span>
    <span class="k">for</span> <span class="n">paulis_this_gamma</span> <span class="ow">in</span> <span class="n">paulis_each_op</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
        <span class="k">for</span> <span class="n">pname_1</span><span class="p">,</span> <span class="n">w_1</span> <span class="ow">in</span> <span class="n">paulis_this_gamma</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">i</span> <span class="o">=</span> <span class="n">pauli_ordering_for_tensor_states</span><span class="p">[</span><span class="n">pname_1</span><span class="p">]</span>
            <span class="n">superpos_ordering1</span> <span class="o">=</span> <span class="n">pauli_ordering_for_superpos_states</span><span class="p">[</span><span class="n">pname_1</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">pname_2</span><span class="p">,</span> <span class="n">w_2</span> <span class="ow">in</span> <span class="n">paulis_this_gamma</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">j</span> <span class="o">=</span> <span class="n">pauli_ordering_for_tensor_states</span><span class="p">[</span><span class="n">pname_2</span><span class="p">]</span>
                <span class="n">superpos_ordering2</span> <span class="o">=</span> <span class="n">pauli_ordering_for_superpos_states</span><span class="p">[</span><span class="n">pname_2</span><span class="p">]</span>
                <span class="n">w_ij</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">w_1</span> <span class="o">*</span> <span class="n">w_2</span><span class="p">)</span>
                <span class="n">w_ab</span><span class="p">[</span><span class="n">superpos_ordering1</span><span class="p">,</span> <span class="n">superpos_ordering2</span><span class="p">]</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">w_1</span> <span class="o">*</span> <span class="n">w_2</span><span class="p">)</span>

    <span class="c1"># Convert from string representation to Pauli objects</span>
    <span class="n">tensor_pauli_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">Pauli</span><span class="p">(</span><span class="n">name</span><span class="p">)</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">tensor_pauli_names</span><span class="p">]</span>
    <span class="n">superpos_pauli_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">Pauli</span><span class="p">(</span><span class="n">name</span><span class="p">)</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">superpos_pauli_names</span><span class="p">]</span>

    <span class="n">forged_operator</span> <span class="o">=</span> <span class="n">EntanglementForgingOperator</span><span class="p">(</span>
        <span class="n">tensor_paulis</span><span class="o">=</span><span class="n">tensor_pauli_list</span><span class="p">,</span>
        <span class="n">superposition_paulis</span><span class="o">=</span><span class="n">superpos_pauli_list</span><span class="p">,</span>
        <span class="n">w_ij</span><span class="o">=</span><span class="n">w_ij</span><span class="p">,</span>
        <span class="n">w_ab</span><span class="o">=</span><span class="n">w_ab</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="k">return</span> <span class="n">forged_operator</span></div>


<span class="k">def</span> <span class="nf">_get_fermionic_ops_with_cholesky</span><span class="p">(</span>
    <span class="n">mo_coeff</span><span class="p">:</span> <span class="n">Matrix</span><span class="p">,</span>
    <span class="n">h1</span><span class="p">:</span> <span class="n">SingleBodyIntegrals</span><span class="p">,</span>
    <span class="n">h2</span><span class="p">:</span> <span class="n">TwoBodyIntegrals</span><span class="p">,</span>
    <span class="n">opname</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
    <span class="n">halve_transformed_h2</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">occupied_orbitals_to_reduce</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">NDArray</span><span class="p">[</span><span class="n">Shape</span><span class="p">[</span><span class="s2">&quot;*&quot;</span><span class="p">],</span> <span class="n">Int</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">virtual_orbitals_to_reduce</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">NDArray</span><span class="p">[</span><span class="n">Shape</span><span class="p">[</span><span class="s2">&quot;*&quot;</span><span class="p">],</span> <span class="n">Int</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">epsilon_cholesky</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1e-10</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">PauliSumOp</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">PauliSumOp</span><span class="p">],</span> <span class="nb">float</span><span class="p">,</span> <span class="n">SingleBodyIntegrals</span><span class="p">,</span> <span class="n">TwoBodyIntegrals</span><span class="p">,]:</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Decompose the Hamiltonian operators into a form appropriate for entanglement forging.</span>

<span class="sd">    Args:</span>
<span class="sd">        - mo_coeff (NDArray[Shape[&quot;N, N&quot;], Float]): 2D array representing coefficients for converting from AO to MO basis.</span>
<span class="sd">        - h1 (NDArray[Shape[&quot;N, N&quot;], Float]): 2D array representing operator</span>
<span class="sd">            coefficients of one-body integrals in the AO basis.</span>
<span class="sd">        - h2 (NDArray[Shape[&quot;N, N, N, N&quot;], Float]): 4D array representing operator coefficients</span>
<span class="sd">            of two-body integrals in the AO basis.</span>
<span class="sd">        - halve_transformed_h2 (Optional[bool]): Should be set to True for Hamiltonian</span>
<span class="sd">            operator to agree with Qiskit conventions.</span>
<span class="sd">        - occupied_orbitals_to_reduce (Optional[NDArray[Shape[&quot;*&quot;], Int]]): Optional; A list of occupied orbitals that will be removed.</span>
<span class="sd">        - virtual_orbitals_to_reduce (Optional[NDArray[Shape[&quot;*&quot;], Int]]):Optional; A list of virtual orbitals that will be removed.</span>
<span class="sd">        - epsilon_cholesky (Optional[float]): The threshold for the decomposition (typically a number close to 0).</span>

<span class="sd">    Returns:</span>
<span class="sd">        - qubit_op (PauliSumOp): H_1 in the Cholesky decomposition.</span>
<span class="sd">        - cholesky_ops (List[PauliSumOp]): L_\\gamma in the Cholesky decomposition</span>
<span class="sd">        - freeze_shift (float): Energy shift due to freezing.</span>
<span class="sd">        - h1 (NDArray[Shape[&quot;N, N&quot;], Float]): 2D array representing operator coefficients of one-body</span>
<span class="sd">            integrals in the MO basis.</span>
<span class="sd">        - h2 (NDArray[Shape[&quot;N, N, N, N&quot;], Float]): 4D array representing operator coefficients of</span>
<span class="sd">            two-body integrals in the MO basis.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">virtual_orbitals_to_reduce</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">virtual_orbitals_to_reduce</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>
    <span class="k">if</span> <span class="n">occupied_orbitals_to_reduce</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">occupied_orbitals_to_reduce</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>

    <span class="n">coeff_mo</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">mo_coeff</span><span class="p">)</span>

    <span class="n">h1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s2">&quot;pi,pr-&gt;ir&quot;</span><span class="p">,</span> <span class="n">coeff_mo</span><span class="p">,</span> <span class="n">h1</span><span class="p">)</span>
    <span class="n">h1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s2">&quot;rj,ir-&gt;ij&quot;</span><span class="p">,</span> <span class="n">coeff_mo</span><span class="p">,</span> <span class="n">h1</span><span class="p">)</span>  <span class="c1"># h_{pq} in MO basis</span>

    <span class="c1"># Do the cholesky decomposition</span>
    <span class="k">if</span> <span class="n">h2</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">num_gammas</span><span class="p">,</span> <span class="n">l_op</span> <span class="o">=</span> <span class="n">_get_modified_cholesky</span><span class="p">(</span><span class="n">h2</span><span class="p">,</span> <span class="n">epsilon_cholesky</span><span class="p">)</span>

        <span class="c1"># Obtain L_{pr,g} in the MO basis</span>
        <span class="n">l_op</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s2">&quot;prg,pi,rj-&gt;ijg&quot;</span><span class="p">,</span> <span class="n">l_op</span><span class="p">,</span> <span class="n">coeff_mo</span><span class="p">,</span> <span class="n">coeff_mo</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">size</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">h1</span><span class="p">)</span>
        <span class="n">num_gammas</span><span class="p">,</span> <span class="n">l_op</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">occupied_orbitals_to_reduce</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">orbitals_not_to_reduce_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
            <span class="nb">sorted</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">h1</span><span class="p">)))</span> <span class="o">-</span> <span class="nb">set</span><span class="p">(</span><span class="n">occupied_orbitals_to_reduce</span><span class="p">))</span>
        <span class="p">)</span>

        <span class="n">h1_frozenpart</span> <span class="o">=</span> <span class="n">h1</span><span class="p">[</span>
            <span class="n">np</span><span class="o">.</span><span class="n">ix_</span><span class="p">(</span><span class="n">occupied_orbitals_to_reduce</span><span class="p">,</span> <span class="n">occupied_orbitals_to_reduce</span><span class="p">)</span>
        <span class="p">]</span>
        <span class="n">h1_activepart</span> <span class="o">=</span> <span class="n">h1</span><span class="p">[</span>
            <span class="n">np</span><span class="o">.</span><span class="n">ix_</span><span class="p">(</span><span class="n">orbitals_not_to_reduce_array</span><span class="p">,</span> <span class="n">orbitals_not_to_reduce_array</span><span class="p">)</span>
        <span class="p">]</span>
        <span class="n">l_frozenpart</span> <span class="o">=</span> <span class="n">l_op</span><span class="p">[</span>
            <span class="n">np</span><span class="o">.</span><span class="n">ix_</span><span class="p">(</span><span class="n">occupied_orbitals_to_reduce</span><span class="p">,</span> <span class="n">occupied_orbitals_to_reduce</span><span class="p">)</span>
        <span class="p">]</span>
        <span class="n">l_activepart</span> <span class="o">=</span> <span class="n">l_op</span><span class="p">[</span>
            <span class="n">np</span><span class="o">.</span><span class="n">ix_</span><span class="p">(</span><span class="n">orbitals_not_to_reduce_array</span><span class="p">,</span> <span class="n">orbitals_not_to_reduce_array</span><span class="p">)</span>
        <span class="p">]</span>

        <span class="n">freeze_shift</span> <span class="o">=</span> <span class="p">(</span>
            <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s2">&quot;pp&quot;</span><span class="p">,</span> <span class="n">h1_frozenpart</span><span class="p">)</span>
            <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s2">&quot;ppg,qqg&quot;</span><span class="p">,</span> <span class="n">l_frozenpart</span><span class="p">,</span> <span class="n">l_frozenpart</span><span class="p">)</span>
            <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s2">&quot;pqg,qpg&quot;</span><span class="p">,</span> <span class="n">l_frozenpart</span><span class="p">,</span> <span class="n">l_frozenpart</span><span class="p">)</span>
        <span class="p">)</span>

        <span class="n">h1</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">h1_activepart</span>
            <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s2">&quot;ppg,qsg-&gt;qs&quot;</span><span class="p">,</span> <span class="n">l_frozenpart</span><span class="p">,</span> <span class="n">l_activepart</span><span class="p">)</span>
            <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span>
                <span class="s2">&quot;psg,qpg-&gt;qs&quot;</span><span class="p">,</span>
                <span class="n">l_op</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ix_</span><span class="p">(</span><span class="n">occupied_orbitals_to_reduce</span><span class="p">,</span> <span class="n">orbitals_not_to_reduce_array</span><span class="p">)],</span>
                <span class="n">l_op</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ix_</span><span class="p">(</span><span class="n">orbitals_not_to_reduce_array</span><span class="p">,</span> <span class="n">occupied_orbitals_to_reduce</span><span class="p">)],</span>
            <span class="p">)</span>
        <span class="p">)</span>
        <span class="n">l_op</span> <span class="o">=</span> <span class="n">l_activepart</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="n">freeze_shift</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">if</span> <span class="n">virtual_orbitals_to_reduce</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
        <span class="n">virtual_orbitals_to_reduce</span> <span class="o">-=</span> <span class="nb">len</span><span class="p">(</span><span class="n">occupied_orbitals_to_reduce</span><span class="p">)</span>  <span class="c1"># type: ignore</span>
        <span class="n">orbitals_not_to_reduce</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span>
            <span class="nb">sorted</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">h1</span><span class="p">)))</span> <span class="o">-</span> <span class="nb">set</span><span class="p">(</span><span class="n">virtual_orbitals_to_reduce</span><span class="p">))</span>  <span class="c1"># type: ignore</span>
        <span class="p">)</span>
        <span class="n">h1</span> <span class="o">=</span> <span class="n">h1</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ix_</span><span class="p">(</span><span class="n">orbitals_not_to_reduce</span><span class="p">,</span> <span class="n">orbitals_not_to_reduce</span><span class="p">)]</span>
        <span class="n">l_op</span> <span class="o">=</span> <span class="n">l_op</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ix_</span><span class="p">(</span><span class="n">orbitals_not_to_reduce</span><span class="p">,</span> <span class="n">orbitals_not_to_reduce</span><span class="p">)]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">pass</span>

    <span class="n">h2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s2">&quot;prg,qsg-&gt;prqs&quot;</span><span class="p">,</span> <span class="n">l_op</span><span class="p">,</span> <span class="n">l_op</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">halve_transformed_h2</span><span class="p">:</span>
        <span class="n">h2</span> <span class="o">/=</span> <span class="mi">2</span>  <span class="c1"># type: ignore</span>
    <span class="n">h1_int</span> <span class="o">=</span> <span class="n">OneBodyElectronicIntegrals</span><span class="p">(</span><span class="n">basis</span><span class="o">=</span><span class="n">ElectronicBasis</span><span class="o">.</span><span class="n">SO</span><span class="p">,</span> <span class="n">matrices</span><span class="o">=</span><span class="n">h1</span><span class="p">)</span>
    <span class="n">h2_int</span> <span class="o">=</span> <span class="n">TwoBodyElectronicIntegrals</span><span class="p">(</span><span class="n">basis</span><span class="o">=</span><span class="n">ElectronicBasis</span><span class="o">.</span><span class="n">SO</span><span class="p">,</span> <span class="n">matrices</span><span class="o">=</span><span class="n">h2</span><span class="p">)</span>
    <span class="n">int_property</span> <span class="o">=</span> <span class="n">IntegralProperty</span><span class="p">(</span><span class="s2">&quot;fer_op&quot;</span><span class="p">,</span> <span class="p">[</span><span class="n">h1_int</span><span class="p">,</span> <span class="n">h2_int</span><span class="p">])</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">int_property</span><span class="o">.</span><span class="n">second_q_ops</span><span class="p">(),</span> <span class="nb">dict</span><span class="p">):</span>
        <span class="n">fer_op</span> <span class="o">=</span> <span class="n">int_property</span><span class="o">.</span><span class="n">second_q_ops</span><span class="p">()[</span><span class="s2">&quot;fer_op&quot;</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">fer_op</span> <span class="o">=</span> <span class="n">int_property</span><span class="o">.</span><span class="n">second_q_ops</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>

    <span class="n">converter</span> <span class="o">=</span> <span class="n">QubitConverter</span><span class="p">(</span><span class="n">JordanWignerMapper</span><span class="p">())</span>
    <span class="n">qubit_op</span> <span class="o">=</span> <span class="n">converter</span><span class="o">.</span><span class="n">convert</span><span class="p">(</span><span class="n">fer_op</span><span class="p">)</span>

    <span class="n">qubit_op</span><span class="o">.</span><span class="n">_name</span> <span class="o">=</span> <span class="n">opname</span> <span class="o">+</span> <span class="s2">&quot;_onebodyop&quot;</span>

    <span class="n">cholesky_op_futures</span> <span class="o">=</span> <span class="p">[</span>
        <span class="n">get_cholesky_op</span><span class="p">(</span><span class="n">l_op</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">converter</span><span class="p">,</span> <span class="n">opname</span><span class="p">)</span> <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">l_op</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
    <span class="p">]</span>
    <span class="n">cholesky_ops</span> <span class="o">=</span> <span class="n">get</span><span class="p">(</span><span class="n">cholesky_op_futures</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">qubit_op</span><span class="p">,</span> <span class="n">cholesky_ops</span><span class="p">,</span> <span class="n">freeze_shift</span><span class="p">,</span> <span class="n">h1</span><span class="p">,</span> <span class="n">h2</span>


<span class="k">def</span> <span class="nf">_get_modified_cholesky</span><span class="p">(</span>
    <span class="n">two_body_overlap_integrals</span><span class="p">:</span> <span class="n">NDArray</span><span class="p">[</span><span class="n">Shape</span><span class="p">[</span><span class="s2">&quot;*, *, *&quot;</span><span class="p">],</span> <span class="n">Float</span><span class="p">],</span> <span class="n">eps</span><span class="p">:</span> <span class="nb">float</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Perform modified Cholesky decomposition on the two-body integrals given an epsilon value.&quot;&quot;&quot;</span>
    <span class="n">n_basis_states</span> <span class="o">=</span> <span class="n">two_body_overlap_integrals</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># number of basis states</span>
    <span class="c1"># Max (chmax) and current (n_gammas) number of Cholesky vectors</span>
    <span class="n">ch_max</span><span class="p">,</span> <span class="n">n_gammas</span> <span class="o">=</span> <span class="mi">10</span> <span class="o">*</span> <span class="n">n_basis_states</span><span class="p">,</span> <span class="mi">0</span>

    <span class="n">w_op</span> <span class="o">=</span> <span class="n">two_body_overlap_integrals</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">n_basis_states</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">n_basis_states</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">l_op</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_basis_states</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">ch_max</span><span class="p">))</span>
    <span class="n">d_max</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diagonal</span><span class="p">(</span><span class="n">w_op</span><span class="p">)</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">nu_max</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">d_max</span><span class="p">)</span>
    <span class="n">v_max</span> <span class="o">=</span> <span class="n">d_max</span><span class="p">[</span><span class="n">nu_max</span><span class="p">]</span>

    <span class="k">while</span> <span class="n">v_max</span> <span class="o">&gt;</span> <span class="n">eps</span><span class="p">:</span>
        <span class="n">l_op</span><span class="p">[:,</span> <span class="n">n_gammas</span><span class="p">]</span> <span class="o">=</span> <span class="n">w_op</span><span class="p">[:,</span> <span class="n">nu_max</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">n_gammas</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">l_op</span><span class="p">[:,</span> <span class="n">n_gammas</span><span class="p">]</span> <span class="o">-=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">l_op</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">:</span><span class="n">n_gammas</span><span class="p">],</span> <span class="n">l_op</span><span class="o">.</span><span class="n">T</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">n_gammas</span><span class="p">,</span> <span class="n">nu_max</span><span class="p">])</span>
        <span class="n">l_op</span><span class="p">[:,</span> <span class="n">n_gammas</span><span class="p">]</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">v_max</span><span class="p">)</span>
        <span class="n">d_max</span><span class="p">[:</span> <span class="n">n_basis_states</span><span class="o">**</span><span class="mi">2</span><span class="p">]</span> <span class="o">-=</span> <span class="n">l_op</span><span class="p">[:</span> <span class="n">n_basis_states</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">n_gammas</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span>
        <span class="n">n_gammas</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">nu_max</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">d_max</span><span class="p">)</span>
        <span class="n">v_max</span> <span class="o">=</span> <span class="n">d_max</span><span class="p">[</span><span class="n">nu_max</span><span class="p">]</span>

    <span class="n">l_op</span> <span class="o">=</span> <span class="n">l_op</span><span class="p">[:,</span> <span class="p">:</span><span class="n">n_gammas</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">n_basis_states</span><span class="p">,</span> <span class="n">n_basis_states</span><span class="p">,</span> <span class="n">n_gammas</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">n_gammas</span><span class="p">,</span> <span class="n">l_op</span>


<span class="k">def</span> <span class="nf">_get_orbitals_to_reduce</span><span class="p">(</span>
    <span class="n">orbitals_to_reduce</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span>
    <span class="n">num_alpha</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">NDArray</span><span class="p">[</span><span class="n">Shape</span><span class="p">[</span><span class="s2">&quot;*&quot;</span><span class="p">],</span> <span class="n">Int</span><span class="p">]]:</span>
    <span class="n">orb_to_reduce_dict</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;occupied&quot;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">orbitals_to_reduce</span><span class="p">),</span>
        <span class="s2">&quot;virtual&quot;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">orbitals_to_reduce</span><span class="p">),</span>
        <span class="s2">&quot;all&quot;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">orbitals_to_reduce</span><span class="p">),</span>
    <span class="p">}</span>

    <span class="c1"># Populate the occupied list within the dict</span>
    <span class="n">orb_to_reduce_dict</span><span class="p">[</span><span class="s2">&quot;occupied&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">orb_to_reduce_dict</span><span class="p">[</span><span class="s2">&quot;occupied&quot;</span><span class="p">][</span>
        <span class="n">orb_to_reduce_dict</span><span class="p">[</span><span class="s2">&quot;occupied&quot;</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">num_alpha</span>
    <span class="p">]</span>

    <span class="c1"># Populate the virtual list within the dict</span>
    <span class="n">orb_to_reduce_dict</span><span class="p">[</span><span class="s2">&quot;virtual&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">orb_to_reduce_dict</span><span class="p">[</span><span class="s2">&quot;virtual&quot;</span><span class="p">][</span>
        <span class="n">orb_to_reduce_dict</span><span class="p">[</span><span class="s2">&quot;virtual&quot;</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">num_alpha</span>
    <span class="p">]</span>

    <span class="k">return</span> <span class="n">orb_to_reduce_dict</span>
</pre></div>

          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../../index.html">Circuit Knitting Toolbox</a></h1>








<h3>Navigation</h3>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../apidocs/index.html">API References</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../index.html">Documentation overview</a><ul>
  <li><a href="../../index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2022.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 5.3.0</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
    </div>

    

    
  </body>
</html>